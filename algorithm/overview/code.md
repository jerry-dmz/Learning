TODO:待整理

#### 什么是算法？

以更小的空间、更少的时间处理输入

#### 为什么要学习算法？

#### 学习算法有哪些困难？

#### 学习算法有什么技巧？

多用几种思路，多从实现中、过程中找问题。

#### 数据结构和算法的关系？

数据结构是为了算法服务的，算法要作用到特定的数据结构上。

数据结构类似于输入，算法会对输入进行处理，输出特定的结果。

#### 算法要学习到什么程度？

**1.**从实际应用场景出发，分析常用的数据结构和算法：

​	常用的10种数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树

​	常用的10种算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

**2.**开始学习分析分析算法：

​	怎么衡量一个算法？更小的空间的占用、更少的时间占用

​	分析算法的方法？定量分析、定性分析

​	定量分析？在特定的环境，给出特定的数据，监控整个过程中资源占用（空间、时间），也被称为事后统计法

​	定量分析的缺点？依赖环境，依赖输入，不能准确反映某个算法的实际优劣

​	定性分析？将算法中的操作基础单元作为基本衡量单位，粗略的分析

​	定性分析中的基础操作单元？每行代码的操作无非就是判断、读写数据，每个操作的时间可以大致认为是相等的

**1.**时间复杂度分析（抽象出来的概念）

分析算法的执行时间随数据规模的增长趋势，将数据规模纳入到了算法的衡量角度

    大前提：假设每个语句的执行时间都是unit_time
    
    结论：所有代码的执行时间和每行代码的执行次数成正比
    
    提出概念：大O时间复杂度表示法（渐进时间复杂度），   代码执行时间随数据规模增长的变化趋势

**2.**根据抽象出的模型得出一些推导结论

    只关注循环执行次数最多一段段代码
     
    总复杂度等于量级最大的那段代码的复杂度
    
    嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

**3.**一些常见的复杂度量级：多项式量级和非多项式量级

多项式量级：常量阶、对数阶、线性阶、线程对数阶、平方阶

非多项式量级：指数阶、阶乘阶

eg.

对数阶：logn

{

i=1;
while(i<=n)
i=i*2;

}

nlogn

{

j=1;

while(j<=n){

​	j++;

​	i=1;
​	while(i<=n)
​		i=i*2;	

}

}

渐进时间复杂度：表示算法的执行时间与数据规模之间的增长关系

渐进空间复杂度：算法的存储空间和数据规模之间的增长关系,空间随数据规模的变化率

**4.**最好情况时间复杂度和最坏情况时间复杂度和平均时间复杂度和均摊时间复杂度

加权平均时间复杂度：考虑每种情况出现的概率

均摊时间复杂度：对一个数据结构进行一组连续操作时，大部分情况下时间复杂度 
都很低，只有个别情况时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系。

**5.**数组：

特点：线性表、连续的内存空间和相同类型的数据，随机访问特性

数组的插入：需要维持顺序的插入（可以直接将插入位置的元素移到最后）、不需要维持顺序的插入

数组的删除：标记删除（将多次删除合并），类似jvm中标记-清除垃圾回收算法

数组越界在c中是一种未决行为

对于业务开发，一般直接使用容器即可；如果是比较底层的开发，数组则由于容器。

例如ArrayList无法存储基本类型，box和unbox需要耗费时间，容器尽量指定初始化大小

如果数组从1开始编号，则寻址时需要多做一次减法

**6.**链表：

缓存淘汰策略：FIFO、LFU、LRU

单链表、循环链表、双向链表、循环双向链表

单链表、双链表插入时效率问题？？？？

数组和链表的对比：数组使用连续的内存空间，可以借助CPU的缓存机制

对链表的插入和删除，容易造成内存碎片;数组扩容时耗费更多时间

##### 使用数组和链表实现LRU算法、实现回文字符串算法

##### 单链表反转、链表中环的检测、有序链表合并、删除链表倒数第n个节点、求链表的中间节点

链表中哨兵节点的编程技巧

**7.**栈：

顺序栈，扩容问题，复杂度分析（使用均摊分析）

链式栈

##### 栈在函数调用中的应用

##### 栈在表达式求值中的应用

##### 栈在括号匹配中的应用

##### 栈实现前进后退的功能

**8.**队列：

应用：阻塞队列、并发队列

实现：顺序队列、链式队列

对于大部分资源有限的场景，当没有空闲的资源时，基本都可以通过队列来排队

##### 循环队列的实现

**9.**递归：

​		一个问题解可以分解为几个子问题的解

​		问题和分解后的子问题，除了数据规模，求解思路完全一样

​		存在递归终止条件

如何将大问题分解为小问题，找到递归边界点

递归存在的问题：堆栈溢出、重复计算

递归算法都可以转换为非递归算法（借助栈）

**如何检测递归中是否存在循环递归的调用？**

##### 跳台阶的问题（斐波那契数列）

**10.**排序：冒泡、插入、选择(基于比较、O(n<sup>2</sup>))；快排、归并(基于比较、O(nlog<sub>n</sub>))；桶排序、计数排序、基数排序(非基于比较、O(n))

排序算法的执行效率：比较次数和交换次数；时间复杂度的系数、常数、低阶(比较同一量级的排序算法)；最好、最坏、平均时间复杂度

排序算法的内存消耗：空间复杂度为O(1)，为原地排序

排序算法的稳定性：订单排序按金额排序，金额相同的按时间排序

冒泡排序：

逆序度=满有序度-有序度，**为什么移动、交换的次数一定为逆序度，怎么推理**

冒泡排序含有两个操作原子：比较和交换，交换次数总是确定的（逆序度）

插入排序：优化（**希尔排序** 如何理解？）

**插入排序和冒泡排序的比较**

选择排序：不稳定

以上三种排序算法适用于小规模

归并排序和快速排序适用于大规模，都用到了分治思想

归并排序：*******

快速排序：*******

**求无序数组的第K大元素**

线性排序：非基于比较的排序算法，桶排序等，但是一般对数据有严格的特征要求

桶排序：将数据分为n个桶，桶与桶之间天然具备大小顺序，比较适合外部排序中（内存300M,数据10G）

计数排序：桶排序的一种特殊情况，最大值K，分为k个桶，省去桶内排序（适合密集、有限的数据），高考成绩

基数排序：**10万个手机号码排序**（利用排序算法的稳定性），对于不对齐的数据，也可以采取对齐的做法

排序优化：

如果实现一个通用的排序函数，线性排序函数的时间复杂度虽然比较低

但是适用场景特殊。java中采用堆排序实现排序函数，c中综合了多种排序算法

如何优化快排，分区点的选择方案（三数取中、随机）

**c语言的qsort实现**：优先使用归并排序，数据量较大时，改用快速排序，排序的区间小于或等于4时，退化成插入排序

java、javascript中排序的**实现**

[世界上最快的排序算法——Timsort - 佛西先森 - 博客园 (cnblogs.com)](https://www.cnblogs.com/sunshuyi/p/12680918.html)

11.二分查找：

针对的是一个有序集合、依赖顺序表结构

只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，将不在适用

如果数据间的比较操作比较耗时，使用二分查找

**求一个数的平方根，精确到小数点后6位**

二分查找的变体：

**查找第一个值等于给定值的元素**

**查找最后一个值等于给定值的元素**

**查找第一个大于等于给定值的元素**

**查找最后一个小于或等于给定值的元素**

12.跳表：链表添加多级索引，可以实现链表形式的二分查找  **复杂度分析**

redis中有序集合由跳表实现

跳表的插入和删除：删除时需要删除索引

也需要动态更新索引，插入的使用使用随机函数选择将节点同步到第几层

索引，避免退化

跳表更加灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗  **有哪些不同的索引构建之法**？？？

13.散列表：利用数组按照下标随机访问数据的特性

真实的情况中，要想找到一个不同的key对应的散列值都不一样的散列函数，

几乎是不可能的，像业界的MD5、SHA、CRC等哈希算法，也无法完全避免散列冲突

而且因为数组空间有限，也会加大散列冲突的概率

解决散列冲突的方法：

开发寻址法：线性探测（在删除时不能将数据真正的删除）**查找、删除过程**、二次探测、双重散列（两个散列函数）

为了尽可能减少hash冲突，需要尽可能保证散列表中有一定比例的空闲槽位（装载因子）

散列表的装载因子=填入表中元素个数/散列表长度？？？？？？

链表法：更加常用，数组+链表

利用散列表实现word文档的单词拼写检查

散列表来源于数组，借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照

下标随机访问元素的特性。散列表的两个核心问题：散列函数设计和散列冲突解决。

**设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能**

**急剧下降，并且能够抵抗散列碰撞攻击。**

如何设计散列函数：不能太复杂，生成的值要尽可能随机并且均匀分布。实际工作中，还需要

综合考虑各种因素，如关键字长度、特点、分布。

直接寻址法、平方取中法、折叠法、随机数法

装载因子过大怎么办：针对散列表的扩容需要进行重新映射

当删除散列表的内容，可以进行动态缩容

如何避免低效的扩容：一次性扩容搬移数据有时候不合适，可以维护一个扩容后的新散列表，每次插入时

将就散列表中内容复制过去，这期间的查询操作需要参考两个散列表中内容

解决散列冲突两种方案的比较：

开放寻址法：可以有效利用CPU缓存，序列化简单。数据量较小，装载因子较小时，ThreadLocalMap

链表法：比较适合存储大对象、大数据量，它更加灵活，支持更多的优化策略

jdk8中对hashmap做了优化，当链表长度过长（默认超过8），链表就转换为红黑树

Redis中的有序集合就是用跳表来实现的

设计一个工业级别散列表的原则：支持快速查询、插入、删除操作；内存占用

**链表、数组实现LRU缓存算法**

**Redis有序集合**

**按访问时间排序的LinkedHashMap本身就是一个支持LRU的缓存系统**

问题：

假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；查找积分在某个区间的猎头 ID 列表；查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。

14.哈希算法：

将任意长度的二进制值串映射为固定长度的二进制值串，这个**映射规则**就算哈希算法

**为什么有hash算法？**

hash算法的原则：

​	从hash值不能反向推导出原始数据

​	对输入数据敏感

​	散列冲突的概率要小

​	执行效率要高效

哈希算法的应用：

**安全加密**---最长用于加密的哈希算法，MD5（消息摘要算法）、SHA（安全散列算法），还有DES、AES  字典攻击 盐的应用

**唯一标识**---图床中快速找到一张图

**数据校验**---BT协议下载文件

**散列函数**---散列函数对散列冲突，能否反向破解的要求小很多，散列的时间快慢更重要

**负载均衡**---需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。可以

通过hash算法，对客户端ip地址或者会话id计算哈希值，将取得的哈希值与服务器列表的大小

进行取模运算，最终得到的值就是应该被路由到的服务器编号。

**数据分片**---“搜索关键词次数”、“如何快速判断图片是否在图床中”   MapReduce的设计思想（论文）

**分布式存储**---使用哈希算法进行计算内容存在的机器，如果增加机器，所有的数据都要重新计算哈希值

，然后重新搬移到正确的机器上，这样缓存中的数据就都失效了。所有的数据都会穿透缓存，这就可能

发生雪崩效应，压垮数据库。一致性哈希算法就是为了应对这种情况。

[Consistent hashing - Wikipedia](https://en.wikipedia.org/wiki/Consistent_hashing)

[白话解析：一致性哈希算法 consistent hashing-朱双印博客 (zsythink.net)](https://www.zsythink.net/archives/1182)

一致性哈希提出在动态变化的cache环境中，哈希算法应该满足4个适应条件，均衡性、单调性、分散性、负载

环形hash

15.树：

节点的高度：节点到叶子节点的最长路径（边数）

节点的深度:根节点到这个节点的所经历的边的个数

节点的层数：节点的深度+1

树的高度：根节点的高度


二叉树--最常用，左子节点、右子节点，并不要求每个节点都有这两个节点 

**满二叉树**：叶子节点全在最底层，除叶子节点之外，每个节点都有左右两个节点

**完全二叉树**：叶子节点都在最底下两层，最后一层的叶子节点都靠左，并且除了最后，其他层的节点个数要达到最大。

完全二叉树的由来：**如何存储一个二叉树？**

**存储二叉树**：基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。

如果完全二叉树，数组是最适宜的存储方式，**堆**其实就是一种完全二叉树。

**如何判断一个树是不是二叉树，如何判断一个树是不是满二叉树，如何判断一个树是不是完全二叉树？**

如何求树的高度、深度、层数

**二叉树的三种遍历、层序遍历？有没有不需要递归的遍历二叉树？**

**卡兰特数**：

二叉树的遍历：前序遍历、中序遍历、后序遍历，是一个递归的过程，把遍历抽象为一个过程

层序遍历


二叉查找树：支持动态数据的快速插入、删除、查找操作

任意一个节点，其左子树节点需要小于此节点，右子树节点需要大于此节点

**二叉查找树的增删改查？**

支持重复数据的二叉查找树：类似哈希表的方式；对于相同的数据放在右子树？？？

**二叉查找树和散列表的区别？**

**二叉查找树的优劣？**

平衡二叉查找树：

二叉树中任意一个节点的左右子树的高度相差不能大于1.

平衡二叉查找树：最先被发明的是AVL树，严格符合平衡二叉查找树的特点

而红黑树则没有严格符合定义要求，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍

发明平衡二叉查找树的初衷时，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的现象。

**为什么频繁插入、删除时，会出现复杂度退化的想象呢？**

平衡二叉查找树其实很多，比如，伸展树、树堆、红黑树等

**R-B Tree**？？？？？？？？

​	1.红黑树中的节点，一类被标记为黑色，一类被标记为红色

​	2.根节点是黑色的

​	3.每个叶子节点都是黑色的空节点

​	4.任何相邻的节点都不能同时为黑色（红色节点被黑色节点隔开）

​	5.每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点

**递归树分析快排算法、斐波那契、全排列的复杂度**

**递归过程中出现死循环如何排查？如何避免递归代码中出现死循环？**

16.堆

一种特殊的树（**注意与二叉排序树的异同**）

​	堆是一个完全二叉树

​	堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值

堆的操作：

往堆中插入一个元素，从堆中删除一个元素，此时都需要进行**堆化**

堆排序：建堆，把堆中最大或最小的元素放到最后的位置

堆排序，数据是跳着访问的，堆CPU缓存不友好；对于同样的数据，由于建堆，会增大原有数据的有序度，使得交换次数增多

堆的应用：**优先级队列**、**求Top K和求中位数**

优先级队列：java的PriorityQueue

​	合并有序小文件，小文件的每个内容都是经过排序的

​	高性能计时器

利用堆求**top k**,**静态数据和动态数据的区别**

求**中位数**，求99%接口的响应时间

17.图

几个概念：

​	顶点：图中的一个节点元素

​	边：顶点与顶点之间建立的关系

​	度：跟顶点相连接的边的条数（无向图）

​	入度、出度：有多少边指向此顶点、有多少边由此顶点出发指向其他顶点（有向图）

微信：无向图

微博：有向图

QQ：带权图，每条边都有一个权重

**图的存储方式**：

邻接矩阵（Adjacency Matrix）：将节点与节点之间的关系用矩阵的方式表示

​	优点：存储方式简单，获取两个顶点之间的关系时，非常高效、方便计算

​	缺点：浪费存储空间

邻接表（Adjacency List）：数组形式的拉链表

优点：存储节省空间

缺点：获取两个顶点之间的关系不是那么简单高效

**如何处理微博这个社交关系？**

18.深度、广度优先搜索

社交网络的六度分割理论 [六度分隔理论 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/六度分隔理论)

**广度优先搜索**

**深度优先搜索**

**和二叉树的深度、广度优先遍历有什么联系和区别？**

**寻找三度好友**

**如何将迷宫抽象成图**

学习数据结构最难的不是理解和掌握原理，而是能灵活的将各种应用场景和问题抽象成对应的数据结构和算法

**一旦一个问题得到了正确的描述，那么就趋近于解决**  问题背景（是一个什么问题）

19.字符串匹配算法

**BF**（Brute Force）算法：暴力匹配算法,需要比对n-m+1次，每次比对n个数字

在实际的开发比较常用，主串和模式串一般不会太长，而且遇到不能匹配的字符可以直接跳到不能匹配的字符后进行匹配

而且BF算法原理简单，不容易出现bug

**RK**（Rabin-Karp）算法：通过hash算法对主串中的n-m+1个子串分别求hash值，然后与模式串的hash值进行匹配

优化：对hash算法进行改进，字符串集合编码成一个进制数（例如a-z,使用26进制），主要是对hash算法进行优化

**BM**（Boyer-Moore）算法：原理复杂、性能是KMP算法的3-4倍，工程中非常常用的一种高效字符串匹配算法

​	几个概念：

​		坏字符：

​		好后缀：

从模式串中倒序开启查找，关键是控制每次向后滑动的次数

时间复杂度分析：[A new proof of the linearity of the Boyer-Moore string searching algorithm | Proceedings of the 18th Annual Symposium on Foundations of Computer Science (acm.org)](https://dl.acm.org/doi/10.1109/SFCS.1977.3)

[Tight bounds on the complexity of the Boyer-Moore string matching algorithm | Proceedings of the second annual ACM-SIAM symposium on Discrete algorithms](https://dl.acm.org/doi/10.5555/127787.127830)

利用模式串本身的特点，在模式串某个字符与主串不匹配时，将模式串往后多移动几位，减少不必要的字符比较

[boyer_moore.pdf (jhu.edu)](http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf)

**KMP**算法（Knuth Morris Pratt）：

多模式串匹配算法（多个模式串和一个主串之间进行匹配）

**Trie树**：字典树，树形结构，专门处理字符串匹配的数据结构，用于解决在一组字符串集合中快速查找某个字符串

例：在['how','hi','her','hello','so','see']中多次查找某个字符串是否存在

利用字符串之间的公共前缀，将重复的前缀合并到一起

Trie树的两个操作：将一个字符串集合构造成Trie树、在Trie树中查询一个字符串

**搜索引擎提示**、**代码自动补全**

**AC自动机**（Aho-Corasick）：在trie树之上，加了类似KMP的next数组

高性能敏感词过滤系统

20.贪心算法

霍夫曼编码、Prim、Kruskal最小生成树、Dijkstra单源最短路径算法

**分糖果、钱币找零、区间覆盖**等问题

在一个非负整数 a 中，我们希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？

假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？

21.分治算法

MapReduce、GFS、BigTable

分治是一种处理问题的思想、递归是一种编程技巧

分解、解决、合并

**需要满足的条件：**

​	原问题和分解成的小问题具有相同的模式

​	原问题分解成的子问题可以独立求解，子问题之间没有相关性

​	具有分解终止条件

​	可以将子问题合并成原问题，合并操作的复杂度不能太高

**如何编程求出一组数据的有序对个数或者逆序对个数**

**二维平面上有 n 个点，如何快速计算出两个距离最近的点对**

**有两个 n*n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？**

分治思想并不仅限于指导编程和算法设计，还经常用在海量数据处理的场景

MapReduce框架只是一个任务调度器，底层依赖GFS来存储数据，依赖Borg管理机器。从GFS中拿数据，交给Borg中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳，就重新从Brog中调度一台机器执行。

22.回溯算法

深度优先搜索算法利用的是回溯算法思想，除了这种算法设计的场景，在很多的实际的软件开发场景，如正则表达式匹配、编译原理中的语法分析等

数独、八皇后、0-1背包、图的着色、旅行商问题、全排列等

23.**动态规划**？？？

适合用来求解最优问题，可以显著降低时间复杂度，提高代码的执行效率

对整个数据结构、算法的大致脉络，有了一个大致的了解之后，现在就需要练习，将整个map进行填充，结合工程实际，培养出一种算法思考的思维

其实算法、数据结构、编程模式，这些都是解决问题的一些惯用套路，只有对这些套路足够熟悉，才能从根本上提高学习的效率，才能接触更多更有趣的玩意儿



跟着《数据结构和算法》的脉络，结合java，先大概的将能实现的数据结构和算法先实现一遍，然后leetcode刷题。

没思路，或者比较烦时，看看公司代码，公司代码看烦了，再看算法

等算法成为习惯之后，专心攻克操作系统、编译原理、js原理、css



**算法训练时的脉络，以及其中遇到的问题：**















































