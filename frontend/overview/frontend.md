# 可视化

可视化更重要的是利用**WebGL**这样的图形系统，来更**高效**的实现更多有趣的**图形**

不能停留在可视化现有的库、框架和工具的使用层面，必须深入技术栈的底层，充分理解数据，掌握视觉呈现相关技术和基本原理。

图形基础-->数学基础-->视觉呈现-->性能呈现

数据的格式和量级决定了图形系统的选择和渲染方式。一个成熟的可视化系统，应该包括**数据引擎**和**渲染引擎**两部分。

可视化是将数据组织成易于为人所理解和认知的结构，然后以图形的方式形象呈现出的理论、方法和技术。

**1.四大图形系统了解**

**HTML+CSS:**

主要还是为实现网页布局，其虽然也可以绘制可视化图表，但绘制的方式并不简洁，从css代码里很难看出数据和图形的对应关系

涉及到浏览器ui构建和内容组织，额外的解析和构建都是必须的。而可视化，不需要复杂的布局，更多的工作在绘制和数据计算。

相比于HTML+CSS，Canvas2D和WebGL更合适去做可视化这一领域的绘图工作。它们的绘图API能直接操作绘图上下文，一般不涉及引擎的其他部分，在重绘图像时，也不会发生回流、重绘。

**Canvas**:提供一个通过js、html的<canvas>元素来绘制图形的方式，可以用于动画、游戏动画、数据可视化、图片编辑以及实时视频处理

​           **Canvas API**主要聚焦于2D图形。而同样使用<canvas>元素的**WebGL API**则用于绘制硬件加速的2D和3D图形。

相比于svg、html**声明式**的绘图，canvas是一种指令式的绘图系统，绘制整个图形的过程就是一系列指令的执行过程，很难单独对canvas绘图的局部进行控制。但是通过数学计算是可以通过定位的方式获取局部图形

[Canvas - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API)

**SVG**:可缩放矢量图形，w3c xml的语言分支之一。svg可以通过定义必要的线和形状来创建一个图形，也可以修改已有的位图，或者将两种方式结合起来创建图形。图形和其组成部分可以形变、合成、或者通过滤镜完全改变外观。

主流的浏览器都支持svg，svg加载慢，实现了dom接口，不需要安装第三方扩展。

渲染引擎中，svg元素和html元素，在输出图形之前都需要经过引擎的解析、布局计算和渲染树生成。

[引言 - SVG | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Introduction)

**WebGL**:WebGL（Web图形库）是一个JavaScript API，可在任何兼容的Web浏览器中渲染高性能的交互式3D和2D图形，而无需使用插件。WebGL通过引入一个与OpenGL ES 2.0非常一致的API来做到这一点，该API可以在HTML5 [<canvas>](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas)元素中使用。 这种一致性使API可以利用用户设备提供的硬件图形加速。

是浏览器提供的Canvas API中的另一种上下文，是Open GL ES规范在web端的实现。可以通过它，用GPU渲染各种复杂的2D和3D图形。WebGL利用了GPU并行处理的特性，在大数据呈现的时候，性能更高。

适用场景：

* 绘制的图形数量特别多
* 对较大图像的细节做像素处理
* 绘制3D物体

GPU实际可以看作一个独立的计算机，有自己的处理器和存储器以及数据处理模型，一般浏览器中会将图层发给GPU，GPU合成最后的图像

**2.传统前端和可视化**

web开发主要以html、css、js来实现内容呈现和用户交互。可视化更多的是同浏览器Canvas、SVG、WebGL等其他图形API打交道。

web开发主要处理块状内容，而可视化需要呈现各种形状

web开发着重处理普通的文本和多媒体信息，渲染普通的、易于阅读的文本和多媒体内容，而可视化则着重于处理结构化数据，渲染各种相对复杂的图表和图形元素。

web开发主要还是关注内容和样式，图形的渲染和绘制是由浏览器底层来完成的，而可视化可能需要深入底层渲染层，真正控制图形的绘制和细节的呈现。

**3.可视化领域的工作**

* 专业呈现各种类型图表的图表库

  echarts、chart.js图表库

* 专业处理地图、地理位置呈现的可视化地理库

  如果要绘制更加复杂的地图，如一座城市的交通线路和建筑物三维模型，或者一个园区的立即建筑模型等，可能要依赖专业的GIS库，如Mapbox、Leaflet等

* 专业处理视觉呈现的渲染库

  如果要绘制其他灵活的图形、图像或者物理模型，可以使用Three.js这样比较通用的渲染库（实际，图表库或GIS地图库本身底层渲染也基于这些渲染库）

* 处理数据的数据驱动框架

  D3.js,更专注处理数据的组织形式，而将数据呈现交给更底层的图形系统（dom、svg、canvas）或图形库（threejs）去完成

**4.canvas绘图**

canvas api大体可以分为两类：一类是设置状态的，可以设置和改变当前的绘图状态，比如改变绘制图形的颜色、高宽、坐标变换等；一类是绘制指令API，用来绘制不同形状的几何图形

save、restore指令可以存储和恢复某个时间的画布状态

canvas渲染起来相当高效，更偏向渲染层。

**5.svg绘图**

**6.WebGL**

使用WebGL绘图，必须深入细节，必须要和内存、GPU打交道，真正控制图形输出的每一个细节。

通用的计算机图形系统概念：

* 光栅：几乎所有现代图形系统都是基于光栅绘制图形的，光栅是指构成图像像素阵列
* 像素：一个像素对应图像上的一个点，通常保存图像上某个具体位置的颜色等信息
* 帧缓存：绘图过程中，像素信息被存放在帧缓存中，其是一块内存地址

数据经过CPU处理，成为具有特定结构的几何信息。然后这些信息被送到GPU中处理。在GPU中经过两个步骤生成光栅信息。

光栅信息会输出到帧缓存中，最终渲染到屏幕上。

这个过程主要做了两件事，对给定的数据结合绘图的场景要素进行计算，最终将图形变为屏幕空间的2D坐标。二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备。

CPU适合处理大型任务。处理图像应用时，实际上就是 计算图片上的每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成一个简单的任务。而GPU就是由大量的小型处理单元构成的。可以保证每个单元处理一个简单的任务

浏览器提供的WebGL API是OpenGL ES的js版本。赋予了开发者操作GPU的能力。

WebGL以顶点和图元来描述几何信息。**顶点**即图形的顶点，**图元**是WebGl可直接处理的图形单元，由WebGL的绘图模式决定，有点、线、三角形等。

因此，绘制过程中，一般需要用到两段着色器，一段叫**顶点着色器** Vertex Shader，负责处理图形的顶点信息；一段叫**片元着色器**，负责处理图形的像素信息。

顶点着色器理解为处理顶点的GPU代码，可以改变顶点的信息。

WebGL从**顶点着色器和图元提取像素点给片元着色器执行代码的过程**，就是**生成光栅信息**的的过程，光栅化过程。**片元着色器**就是处理光栅化的像素信息

片元着色器对像素点着色的过程都是并行的。

了解下图形学的发展历程%TODO:？？？









