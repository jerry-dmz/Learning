{"root":{"data":{"id":"d9n7pm3wnyw0","created":1746345209912,"text":"动态链接","note":null,"expandState":"expand"},"children":[{"data":{"id":"d9n7qmvimn40","created":1746345289945,"text":"需求","layout_mind_offset":{"x":-519,"y":-96},"expandState":"expand","layout_fish-bone-master_offset":{"x":-20,"y":-22}},"children":[{"data":{"id":"d9n7qp4xnxc0","created":1746345294868,"text":"节省内存","note":"静态链接浪费内存、磁盘","layout_right_offset":{"x":0,"y":-21}},"children":[]},{"data":{"id":"d9n7qpmrils0","created":1746345295947,"text":"兼容/扩展性","note":"程序的更新的很麻烦，每次都要重新链接"},"children":[]}]},{"data":{"id":"d9n7sqpf6nc0","created":1746345455012,"text":"特性","layout_mind_offset":{"x":-532,"y":32},"expandState":"expand","layout_fish-bone-master_offset":{"x":-41,"y":15}},"children":[{"data":{"id":"d9n7syy8obk0","created":1746345472960,"text":"延迟链接","layout_left_offset":{"x":-30,"y":4}},"children":[]},{"data":{"id":"d9n7t6nqx540","created":1746345489740,"text":"动态链接器","note":"程序装载时，动态链接器会将程序所需要的所有动态链接库装载到进程地址空间，并且将所有未决议的符号绑定到相应的动态链接库，并进行重定位\n\n\nLib.so中保留了完整的符号信息，编译时将目标文件对Lib.so中符号的引用标记为动态链接符号，不对其进行地址重定位","layout_fish-bone-slave_offset":{"x":6,"y":7}},"children":[]},{"data":{"id":"d9n7u1g80x40","created":1746345556765,"text":"性能降低","note":"\t"},"children":[]}]},{"data":{"id":"d9nd73fhlag0","created":1746360685358,"text":"寻址模式","layout_mind_offset":{"x":12,"y":-241},"layout_fish-bone-master_offset":{"x":561,"y":313},"note":"static int a;\nextern int b;\nextern ext();\n\nvoid bar()\n{\n\t//访问模块内部数据\n\ta=1;\n    //访问模块外部数据\n    b=2;\n}\n\nvoid foo()\n{\n    //访问模块内部函数\n\tbar();\n    //访问模块外部函数\n    ext();\n}","expandState":"expand"},"children":[{"data":{"id":"d9nddsr6zvs0","created":1746361210670,"text":"模块内部函数","note":"相对地址调用或基于寄存器的相对调用"},"children":[]},{"data":{"id":"d9nddt883bk0","created":1746361211700,"text":"模块内部数据","note":null,"layout_fish-bone-slave_offset":{"x":-117,"y":-117},"expandState":"expand"},"children":[{"data":{"id":"d9ndj455oa00","created":1746361627280,"text":"例子","note":"push %ebp;\nmov %esp,%ebp;\ncall 494<__i686.get_pc_trunk.cx>\n\nadd $0x118c,%ecx\n//把立即数0x01存储到ecx+0x28为地址的内存单元\nmovl $0x1,0x28(%ecx)  // a = 1\n//从ecx+0xfffffff8为地址的内存单元读取一个32位的值，将其存放到eax中\nmov 0xfffffff8(%ecx),%eax\nmovl $0x02,(%eax) // b = 2\npop ebp\nret\n\n<__i686.get_pc-trunk.cx>:\nmov (%esp),%ecx\nret\n\n//处理器执行call指令后，下一条指令地址会压栈，esp始终指向栈顶，所以get_pc_trunk将获取的指令地址从ecx返回"},"children":[]},{"data":{"id":"d9ndj4tadtk0","created":1746361628739,"text":"思路","note":"获取PC值，然后加上一个偏移","layout_filetree-up_offset":{"x":5,"y":2}},"children":[]},{"data":{"id":"d9ndj5f952w0","created":1746361630067,"text":"问题","note":"现代体系结构中，数据的相对寻址没有相对于当前PC寻址的方式。"},"children":[]}]},{"data":{"id":"d9nddtk3w0w0","created":1746361212418,"text":"模块外部数据","layout_fish-bone-slave_offset":{"x":-113,"y":-113}},"children":[{"data":{"id":"d9ndxfboh5s0","created":1746362748717,"text":"GOT","note":"在数据段建立Global Offset Table，代码引用模块外全局变量时，可以通过GOT中相对应项间接引用\n\n链接器装载模块时查找填充变量地址\n\n地址无关性：\n\n编译时可以确定GOT相对当前指令偏移，然后可以通过get_pc_trunk方式相对寻址\n\n\n\n"},"children":[]}]},{"data":{"id":"d9nddtv038w0","created":1746361213077,"text":"模块外部函数","layout_fish-bone-slave_offset":{"x":-25,"y":-25}},"children":[{"data":{"id":"d9ne1af88kg0","created":1746363051504,"text":"GOT","note":"表项保存的是函数地址，比如：\n\ncall <__i686.get_pc_trunk.cx>\n\nadd $0x118c,%ecx\n\nmov 0xfffffffc(%ecx),%eax\n\ncall *(%eax)\n\n"},"children":[]}]}]},{"data":{"id":"d9t8c5704ko0","created":1746956335210,"text":"延迟绑定","layout_fish-bone-master_offset":{"x":285,"y":-267},"note":"静态链接比动态链接大约要快1%~5%，需要采取一些策略对其进行性能优化，\n比如延迟绑定：\n函数第一次被调用时才进行符号查找、重定位\n\nProcedure Linkage Table\n\nbar()函数在PLT中项地址为bar@plt，其实现：\njmp *(bar@GOT)\npush n\npush moduleID\njmp _dl_runtime_resolve\n\nbar@GOT保存bar函数地址。为了实现延迟绑定，链接器在初始化时并没有将正确地址填入，而是将push n地址填入\n\n其中n是bar在.rel.plt中下标\n\nELF将GOT拆分为.got、.got.plt，前者用于保存全局变量引用地址，后者用于保存函数引用地址\n\n","expandState":"expand"},"children":[{"data":{"id":"d9t8lzkfzjc0","created":1746957106603,"text":".got.plt","note":"第二项、第三项由动态链接器初始化\n\n其余项分别对应每个外部函数的引用\t\n\n变量符号还是存放在.got中，函数符号存放在.got.plt中，为了实现延迟链接","expandState":"expand"},"children":[{"data":{"id":"d9tce7xo3200","created":1746967782343,"text":"后续项","note":"初始化对应push n这条指令的地址。\n后续为函数的真正地址\n\n其中n为函数在.rel.plt中项"},"children":[]},{"data":{"id":"d9t8mgdkd000","created":1746957143193,"text":"第三项","note":"_dl_runtime_resolve地址"},"children":[]},{"data":{"id":"d9t8mh3pg9c0","created":1746957144773,"text":"第二项","note":"本模块ID"},"children":[]},{"data":{"id":"d9t8mij5nrc0","created":1746957147884,"text":"第一项","note":"保存.dynamic段地址，此段描述了本模块动态链接相关信息\n\n对于现代x86_64可能不是哦，第一项是got的自身基址"},"children":[]}]},{"data":{"id":"d9tcgyzvhkw0","created":1746967997978,"text":".plt","note":"和.got.plt配合完成延迟绑定","layout_fish-bone-slave_offset":{"x":2,"y":-1}},"children":[{"data":{"id":"d9tch33clwo0","created":1746968006896,"text":"后续项"},"children":[]},{"data":{"id":"d9tch3okwa00","created":1746968008179,"text":"第一项","note":"PLT[0]:\n\n//压入动态链接器句柄\npush QWORD PTR [GOTPCREL+GOT[2]]\n\n//跳转到_dl_runtime_resolve\njmp QWORD PTR [GOTPCREL+GOT[1]]\n\n后续PLT条目：\n\n//跳转至GOT中保存的地址\njmp qword ptr [gotpcrel+symbol@GOT]\n//压入符号在重定位表中的索引（.rel.plt）\npush n  \n//跳转到PLT[0]解析符号\njmp PLT[0] "},"children":[]}]},{"data":{"id":"da597cglk2w0","created":1748177499796,"text":".rel.plt","note":"对函数引用的修正，修正的位置位于.got.plt","layout_fish-bone-slave_offset":{"x":-8,"y":-11}},"children":[]}]},{"data":{"id":"da59o7u1efc0","created":1748178821916,"text":"实现","expandState":"expand","layout_fish-bone-master_offset":{"x":327,"y":28},"layout_mind_offset":{"x":-27,"y":26}},"children":[{"data":{"id":"da59ocaoykw0","created":1748178831630,"text":"自举","note":"动态链接器：\n1.不依赖其它对象\n2.动态链接器本身依赖的全局和静态变量的重定位工作由它本身完成--自举\n\n自举过程：\n1.首先会找到自己的GOT,GOT第一个入口保存的就是\".dynamic\"段偏移地址\n2.通过\".dynmic\"段，可以获取动态链接器本身重定位表和符号表。\n3.对自己进行重定位"},"children":[]},{"data":{"id":"da59ob49lo00","created":1748178829065,"text":"装载共享对象","layout_fish-bone-slave_offset":{"x":6,"y":-6},"note":"自举后，动态链接器将可执行文件和链接器本身符号和全局符号表\n\n开始可执行文件依赖的共享对象\n"},"children":[]},{"data":{"id":"da5acmshai00","created":1748180735213,"text":"重定位"},"children":[]}]},{"data":{"id":"da5a0sdynaw0","created":1748179807026,"text":"数据结构","layout_fish-bone-master_offset":{"x":-92,"y":-229},"expandState":"collapse","layout_mind_offset":{"x":-39,"y":353}},"children":[{"data":{"id":"da5a1fsnmrs0","created":1748179857981,"text":".got"},"children":[]},{"data":{"id":"da5a1j8mjvs0","created":1748179865477,"text":".got.plt"},"children":[]},{"data":{"id":"da5a1sfnio80","created":1748179885493,"text":".plt","note":"延迟绑定"},"children":[]},{"data":{"id":"d9tdhctq96o0","created":1746970849192,"text":".interp","note":"存放动态链接器路径\n\n在linux下，是Glibc的一部分，属于系统库级别\n\n这个路径一般是个软链接：/lib/ld-linux.so.2，其指向最新的动态链接器\n"},"children":[]},{"data":{"id":"d9tdlh76h6g0","created":1746971172169,"text":".dynamic","note":"表项由一个类型值和指针组成，不同类型值代表指针含义不同\n\n保存了动态链接器所需要的基本信息，比如依赖于那些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。\n"},"children":[]},{"data":{"id":"d9te1s1vahs0","created":1746972449619,"text":".dynsym","note":"只保存和动态链接相关符号。\n.symtab往往保存了所有符号（包括.dynsym）。\n\t"},"children":[]},{"data":{"id":"da593vho1u00","created":1748177227764,"text":".dynstr","note":"动态符号字符串表"},"children":[]},{"data":{"id":"da593x4yzr40","created":1748177231349,"text":".hash","note":"辅助加速查找过程"},"children":[]},{"data":{"id":"da597aneecw0","created":1748177495854,"text":".rel.dyn","note":"对数据引用的修正，它所修正的位置位于.got以及数据段\n"},"children":[]}]},{"data":{"id":"da5a3w5ycr40","created":1748180050342,"text":"方案","layout_fish-bone-master_offset":{"x":48,"y":583},"expandState":"collapse","layout_mind_offset":{"x":403,"y":407}},"children":[{"data":{"id":"d9nd9xtoj1s0","created":1746360908248,"text":"方案1（静态共享库）","expandState":"expand","layout_fish-bone-slave_offset":{"x":-848,"y":1490},"layout_right_offset":{"x":466,"y":3}},"children":[{"data":{"id":"d9nday4ojg80","created":1746360987277,"text":"缺点","expandState":"collapse","layout_right_offset":{"x":317,"y":-25}},"children":[{"data":{"id":"d9n8gur6o4g0","created":1746347344566,"text":"升级难","layout_right_offset":{"x":14,"y":-1},"note":"升级后的共享库必须保持共享库中全局变量和函数地址不变\n\n即使只是新增一批全局函数、变量也会遭受到限制（模块的大小是提前划分的）"},"children":[]},{"data":{"id":"d9n8gu0ayxc0","created":1746347342941,"text":"地址冲突","layout_right_offset":{"x":4,"y":-28},"note":"魔魁"},"children":[]}]},{"data":{"id":"d9ndb50t1ds0","created":1746361002280,"text":"思路","note":"将程序的各个模块交由OS管理，OS在某个特定的地址划分出一些地址块，为已知的模块预留足够空间","layout_right_offset":{"x":340,"y":-9}},"children":[]}]},{"data":{"id":"d9nd988sq5k0","created":1746360852565,"text":"方案2（装载时重定位）","expandState":"expand","note":"装载时重定位\n-shared参数\n\n装载时重定位需要修改指令，所以没有办法做到一份指令在多个进程之间共享\n\n因为动态模块要映射进程序的进程空间，所以模块中指令部分需要修改\n\n非PIC模式设计逻辑基于一个核心假设：\n\n“共享模块被装载到操作系统预设的固定虚拟地址(基址)”\n\n在这一假设下，编译器可以直接生成绝对地址指令\n\n生成绝对引用指令的初衷：编译逻辑简单，本质上是静态链接思维的“延伸”","layout_fish-bone-slave_offset":{"x":4,"y":1268},"layout_right_offset":{"x":426,"y":-35}},"children":[{"data":{"id":"d9n9ilb4y5c0","created":1746350301843,"text":"特点","expandState":"expand","layout_right_offset":{"x":596,"y":31}},"children":[{"data":{"id":"d9n9ed42uq00","created":1746349970545,"text":"复用代码为目标","note":"早期目标是复用代码，而非极致的内存共享效率\n\n非PIC模式服用了静态链接的绝对地址模型，仅通过装载时重定位解决\"基址变化\"问题，显著降低了实现难度","layout_right_offset":{"x":331,"y":-127}},"children":[]},{"data":{"id":"d9n9eej70c00","created":1746349973636,"text":"硬件架构限制","layout_right_offset":{"x":331,"y":47},"note":"早期硬件缺乏高效的“相对地址寻址”能力\n\n以"},"children":[{"data":{"id":"d9naexen24w0","created":1746352835829,"text":"x86_32","layout_right_offset":{"x":317,"y":-96},"expandState":"collapse"},"children":[{"data":{"id":"d9nagfonfbs0","created":1746352953981,"text":"绝对地址主导","layout_right_offset":{"x":250,"y":-25},"note":"32位中，函数调用和数据访问普遍使用绝对地址，指令直接编码32位地址值"},"children":[]},{"data":{"id":"d9nagg6q3ww0","created":1746352955074,"text":"PC缺乏相对寻址","layout_right_offset":{"x":256,"y":21},"note":"x86_32的eip早期仅用于指令执行，不能作为基址寄存器进行相对寻址"},"children":[]}]},{"data":{"id":"d9nag6jlnxc0","created":1746352934085,"text":"ARM","layout_right_offset":{"x":347,"y":32},"note":"早期就支持PC相对寻址"},"children":[]}]}]},{"data":{"id":"d9n9l2rugo80","created":1746350496587,"text":"缺点","layout_right_offset":{"x":383,"y":38},"expandState":"expand"},"children":[{"data":{"id":"d9n9l71sjl40","created":1746350505895,"text":"指令共享","note":"每个进程必须修改指令中的绝对地址，导致相同模块在不同进程中占用独立的内存空间","layout_right_offset":{"x":222,"y":-7}},"children":[]},{"data":{"id":"d9n9l7g2fco0","created":1746350506759,"text":"安全问题","note":"装载时重定位需要修改指令段，必须临时开启写权限，存在被攻击风险","layout_right_offset":{"x":224,"y":-3}},"children":[]}]}]},{"data":{"id":"d9nd9ydyoo00","created":1746360909474,"text":"方案3(PIC)","expandState":"expand","note":"readelf -d foo.so | grep TEXTREL\n判断so是否为PIC库，TEXTREL表示代码段重定位表地址","layout_fish-bone-slave_offset":{"x":171,"y":407},"layout_right_offset":{"x":324,"y":30}},"children":[{"data":{"id":"d9naropar1k0","created":1746353835617,"text":"基本思路","layout_right_offset":{"x":358,"y":3},"note":"把指令中那些需要被修改的部分分离出来，跟数据部分放在一起\n\nPosition-independent Code技术","layout_fish-bone-slave_offset":{"x":-111,"y":-59}},"children":[]},{"data":{"id":"d9ne8ja7k0g0","created":1746363619341,"text":"PIE","layout_fish-bone-slave_offset":{"x":3,"y":18},"note":"-fPIE pic技术除了可以用在共享对象上，还可以用于可执行文件。","layout_right_offset":{"x":368,"y":28}},"children":[]},{"data":{"id":"d9nawp20esg0","created":1746354228206,"text":"必要性","layout_right_offset":{"x":361,"y":45},"note":"既然x86_64支持rip基址寻址，那么为什么需要PIC呢？ ","expandState":"collapse","layout_fish-bone-slave_offset":{"x":-50,"y":-435}},"children":[{"data":{"id":"d9naww2aa7c0","created":1746354243460,"text":"仅覆盖段内引用"},"children":[]},{"data":{"id":"d9nawwjm4fs0","created":1746354244508,"text":"ASLR","note":"地址空间布局随机化，"},"children":[]},{"data":{"id":"d9nawwxv7c00","created":1746354245370,"text":"跨平台/编译器规范"},"children":[]}]}]}]},{"data":{"id":"dag5et3jemg0","created":1749283959645,"text":"linux动态链接器","note":"/lib/ld-linux.so.2\n\nlinux动态链接器是Glibc的一部分，是共享对象\n\n动态链接器本身是静态链接的"},"children":[]},{"data":{"id":"dag5f2bgkl40","created":1749283979716,"text":"显式运行时链接","layout_mind_offset":{"x":570,"y":-194},"note":"运行时加载指定模块，在不需要时将其卸载"},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}