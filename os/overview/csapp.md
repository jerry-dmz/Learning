《深入理解计算机》

大部分现代计算系统都使用ASCLL标准来表示文本字符，这种方式就是使用一个唯一的单字节大小的整数值来表示每个字符。

hello.c就是以字节序列的方式存储在文件中的。像这种文件称为**文本文件**，所有其他文件都称为**二进制文件**。

hello.c的表示方法说明了一个**基本思想**：系统中所有的信息--磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。

区分不同数据对象的唯一方法是读取这些数据对象时的上下文。**信息 = 位+上下文**

<img src="..\images\5.png" alt="image-20211114000837003" style="zoom: 67%;" />

* 预处理器，将头文件内容真正插入到文件中，通常用i作为扩展名
* 编译阶段，将文本文件hello.i翻译成文本文件hello.s 。为不同语言、不同编译器提供统一的格式
* 汇编阶段，将文本文件hello.s翻译成机器语言指令hello.o，将指令打包成**可重定位目标程序**(relocatable object program)的格式
* 链接阶段，得到hello**可执行文件**

GCC编译器已经发展到支持不同的语言，能够为许多不同的机器生成代码

![image-20211114002127053](..\images\7.png)



**高速缓存至关重要**

![image-20211114002741119](..\images\8.png)

![image-20211114002924377](..\images\9.png)

**虚拟内存：**

为每个进程提供一个假象，即每个进程都在独占的使用主存（**虚拟地址空间**）

<img src="C:\Users\dmzc\Desktop\Learing\os\images\10.png" alt="image-20211114003416341" style="zoom:67%;" />

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。**基本思想是把一个进程虚拟内存的内容存储到磁盘上，然后用主存作为磁盘的告诉缓存**(**ELF**???)

**文件**：

文件就是**字节序列**,它向应用程序提供了一个统一的视图，来看待系统中可能包含的所有各式各样的I/O设备。

**并发与并行**:

* **线程级并发**，多核处理器是将多个CPU("核")集成到一个**集成电路芯片**上，每个核都有自己的**L1和L2高速缓存**；其中L1告诉缓存分为两个部分：

  一个 保存最近取到的指令，另一个存放数据。这些核共享更高层次的**高速缓存L3**，以及到主存的接口。

  <img src="C:\Users\dmzc\Desktop\Learing\os\images\11.png" alt="image-20211114005643002" style="zoom:50%;" />

  **超线程**，**TODO:**一项允许一个CPU执行多个控制流的技术。

* **指令级并行**，早期的微处理器，如**Intel 8086**,需要多个**（3~10个）时钟周期来执行一条指令**。最近的处理器可以保持**每个时钟周期2~4条指令**的执行效率。其实每条指令从开始到结束需要长的多的时间，大约**20个周期**，但是处理器使用了非常多的聪明技巧，将执行一条指令所需要的活动分为不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤,这些阶段可以并行操作，用来处理不同指令的不同部分。

  如果处理器可以达到一个周期一条指令更快的执行速率，就称为**超标量处理器**。大多数现代处理器都支持超标量操作

* **单指令、多数据并行**，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，SIMD。提供这些SIMD指令是为了提高处理影像、声音和视频数据应用的执行速度。

**抽象很重要**：

**文件**是对**I/O设备**的抽象，**虚拟内存**是对**程序存储器**的抽象，**进程**是对一个**正在运行的程序**的抽象，**虚拟机**提供了对整个计算机的抽象，包括操作系统、处理和程序。



##### 信息的表示和处理

对二值信号进行存储和执行计算的电子电路非常简单可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。

整数的表示虽然只能编码一个相对较小的数值范围，但是是精确的。浮点数虽然可以编码一个较大的数值范围，但是只是近似的。

大量的计算机漏洞都是由于计算机算术运算的微妙细节引发的。

C++编程语言建立在C基础之上，它们使用相同的数字表示和运算。java创造了一套新的数字表示和运算标准。

大多数计算机使用8位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。

为了避免由于依赖“典型”大小和不同编译器设置带来的行为，ISO C99引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型int32_t和int64_t,分别为4个字节和8个字节。

对于跨越多字节的程序对象的寻址，这个对象地址是什么，以及如何在内存中排列这些对象（大端法、小端法）

大多数Intel兼容机都只用小端模式。另一方面，IBM和Oracle的大多数机器则是按大端模式操作。许多比较新的微处理器是双端法，可以把他们配置成作为大端或者小端的机器运行。

二进制很少能在不同机器和操作系统组合之间移植。从机器角度，程序仅仅是字节序列，机器没有任何关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

##### **程序的机器级表示**

**8086**（1978年，**29k**），是第一代单芯片、16位微处理器之一。8088是8086的一个变种，在8086的基础上增加了一个8位外部总线

**80286**（1982年，**134k**），增加了更多寻址模式

**i386**(1985年，**275K**)，将体系结构**扩展到32位**

**i486**(1989年，**1.2M**)，改善了性能，同时将**浮点单元集成到处理器芯片**，但是指令集没有明显变化

**Pentium**(1993,**3.1M**)，改善了性能，对指令集进行了小的扩展

**PentiumPro**(1995，**5.5M**）,引入了**全新的处理器设计**，在内部被称为**P6**微体系架构。指令集内增加一类“条件传送”指令

**Pentium/MMX**(1997，**4.5M**）,在Pentium处理器中增加了一类新的处理整数向量的指令。**TODO:**

**Pentium  II**(1997，**7M**）,**p6**微体系架构的延伸

**Pentium III**(1999，**8.2M**）,引入了SSE，这是一类处理整数或浮点数向量的指令

**Pentium 4**(2000，**42M**）,SSE扩展到SSE2

**Pentium 4E**(2004，**125M**）,增加了**超线程**，这种技术可以在一个处理器上同时运行两个程序；增加了**EM64T**，它是Intel对AMD提出的对IA32的64扩展的实现，称之为**x86_64**

**Core2**(2006,**291M**),**回归**到类似**P6**的微体系架构。Intel的**第一个多核微处理器**，不支持超线程

.......

gcc -Og告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。

对于机器级编程，两种抽象最为重要。**第一种**，指令集体系结构(**ISA**)来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响；大多数ISA，包括x86-64,将程序的行为描述成好像每条指令都是按顺序执行的；处理器的硬件远比描述的精细复杂。**第二种**，机器级程序使用的是内存地址是**虚拟地址**。

x86-64的机器代码和原始的C代码差别很大，一些通常对C隐藏的处理器状态都是可见的：

* PC，x86-64中用%rip表示
* 整数寄存器包含16个命名的位置，分别存储64位的位置。这些寄存器可以存储的地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程中的参数和局部变量，以及函数的返回值。
* 条件码寄存器保存最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件变化。
* 一组向量寄存器，可以存放一个或多个整数或浮点数值

程序内存包含：程序可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。程序内存用**虚拟地址**寻址，操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

一条机器指令只执行一个非常基本的操作。例如，将两个寄存器的数字进行加减，在存储器和寄存器之间传输数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令序列，从而实现类似C语言的程序结构。

**objdump -d，反汇编**

* x86-64的指令长度从1到15个字节不等
* 设计指令格式的方式，从某个给定的位置开始，可以将字节唯一的解码为机器指令。pushq %rbx是以值53开头的。
* 反汇编器只是基于机器文件中的字节序利来确定汇编代码
* 反汇编器使用的指令命名规则于GCC生成的汇编使用有细微差别

ATT是GCC、OBJDUMP和其他一些使用工具的默认汇编格式。其他一些编程工具，包括微软，以及Intel的文档，其汇编代码都是Intel格式的。

在C程序中插入汇编代码：

* 编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和C语言书写的代码合并
* 使用GCC内联汇编特性，用asm伪指令可以在C程序中包含简短的汇编代码

Intel用术语，字(word)-16位，双字(double words)-32位，四字(quad words)-64位

![image-20211114151319595](C:\Users\dmzc\Desktop\Learing\os\images\12.png)

<img src="C:\Users\dmzc\Desktop\Learing\os\images\13.png" alt="image-20211114161903659" style="zoom: 80%;" />

8086有8个16位的寄存器，即%ax~%sp；扩展到IA32架构时，8个通用寄存扩展成32位，%eax~%esp；x86-64后，原来的8个寄存器扩展成了64位，%rax`%rsp,此外还增加了8个新的寄存器，%r8~%r15

如图中的方框标明的，指令可以对16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器

少量指令会使用特定的寄存器。更重要的是，**有一组标准的编程规范**控制着如何使用寄存器来管理栈、传递函数参数、从函数返回值，以及存储局部和临时数据。

**操作数指示符**：

大多数指令有一个或多个**操作数**，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据值可以用**常数形式**给出，或者是从寄存器或内存中读出。结果可以存放到寄存器或内存中。

<img src="C:\Users\dmzc\Desktop\Learing\os\images\14.png" alt="image-20211114163624891"  />



* 数据传送指令：movb、movw、movl、movq,源操作数指定的值是一个立即值，存储在寄存器中或者内存中，目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址，x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。大多数情况下，mov指令以寄存器作为目的时，只会更新目的操作数指定的那些寄存器或内存位置。唯一的例外，movl指令以寄存器作为目的时，会把寄存器的高位4字节置为0,x86-64的惯例。

  ![image-20211115220653502](C:\Users\dmzc\Desktop\Learing\os\images\15.png)

  movabsq指令能够以任意64位立即数值作为源操作数

  <img src="C:\Users\dmzc\Desktop\Learing\os\images\16.png" alt="image-20211115221023562" style="zoom:80%;" />

* 压栈和弹栈指令，pushq、popq

![image-20211120171107070](C:\Users\dmzc\Desktop\Learing\os\images\17.png)

* 加载有效地址，leaq，将有效地址写入到目的地，如leaq (%rdi,%rsi,4),%rax（其中rdi=x,rsi=y,rax=z）,则为z=x+4*y

* 一元和二元操作，x++,y-=1,一元操作只有一个操作数，既是源又是目的，可以是一个寄存器，也可以是内存位置；二元操作，第二个操作数既是源，又是目的，源操作数是第一个，第一个操作数可以是立即数、寄存器或内存位置，第二个操作数可以是寄存器或内存位置。如果第二个操作数为内存，处理器必须从内存中读出值，进行操作，最后把结果写回内存。

* 移位操作，移位量可以是一个立即数，或者放在单字节寄存器%cl中

* 特殊算术操作

  ![image-20211120185913156](C:\Users\dmzc\Desktop\Learing\os\images\18.png)

机器代码提供两种基本的低级机制来实现有条件的行为：**测试数据值**  **根据测试的结果来改变控制流或数据流**

* 条件码，除了整数寄存器，CPU还维护着一组单个位的条件码寄存器，用于描述最近的算术或逻辑操作的属性。还可以检测这些寄存器来执行条件分支指令。

  CF：进位标志。最近的操作使最高位了进位。可用来检查无符号操作的溢出

  ZF：零标志。最近的操作得出的结果为0

  SF:符号标志。最近的操作得到的结果为负数

  OF：溢出标志。最近的操作导致一个补码溢出

  leaq指令不会改变任何条件码，因为它是用来进行地址计算的。对于逻辑操作，进位标志和溢出标志会设置为0。对于移位操作，进位标志将设置为最后一个被移出的位。inc、dec会设置溢出和零标志，但是不会改变进位标志。

  除了指令的副作用会设置条件码。还有两类指令，只设置条件码而不改变任何其他寄存器。CMP会根据两个操作数之差来设置条件码。TEST指令会根据两个操作数之和设置条件码。

* 访问条件码，条件码通常不会直接读取；可以根据条件码的某种组合，将一个字节设置位0或者1；可以条件跳转到程序的某个其他部分；可以有条件的传送数据。

  一条SET指令的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置为0或1.

  ![image-20211120192518431](C:\Users\dmzc\Desktop\Learing\os\images\19.png)

  某些底层的机器指令可能有多个名字，称为“同义名”。setg("设置大于")和setnle("设置不小于等于")，指的是同一条机器指令，编译器和反汇编器会随意决定使用哪个名字

* 跳转指令，产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标编码为跳转指令的一部分

![image-20211120193436495](C:\Users\dmzc\Desktop\Learing\os\images\20.png)

当执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的指令

rep后面跟ret的组合是为了避免使ret指令称为条件跳转指令的目标。

**条件控制实现条件分支**

![image-20211120195027661](C:\Users\dmzc\Desktop\Learing\os\images\21.png)



**条件传送实现条件分支**

实现条件操作的传统方法是通过使用**控制**的**条件转移**。当条件满足时，程序沿着一条分路执行路径执行，当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，可能非常低效。

一种可替代的策略是使用“**数据的条件转移**”**TODO:**

**循环**：基于控制的条件转移

**switch**：跳转表

**过程**

过程是软件中一种很重要的抽象。提供一种封装代码的方式，用一组指定的参数和一个可选的返回值实现某种功能。然后在程序中不同的地方调用这个函数。

设计良好的软件用过程作为抽象机制，隐藏某个实现的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是那些值，过程会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：函数、方法、子例程、处理函数等，但都有一些共同的特性：

*传递控制*：进入过程Q时，PC必须被设置为Q的代码起始地址，返回时，要把PC设置为P中调用Q后面那条指令的地址。

*传递数据*：P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。

*分配和释放内存* ：开始时，Q可能为局部变量分配空间，而在返回前，又必须释放这些存储空间。

X86-64的**过程实现**包括一组特殊指令和一些对机器资源（例如寄存器和程序内存）使用的约定规则。

<img src="C:\Users\dmzc\Desktop\Learing\os\images\22.png" alt="image-20211125212137671" style="zoom: 80%;" />

x86-64的栈向低地址方向增长，而栈指针%rsp指向栈顶元素。当x86-64过程需要的存储空间超过寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧。当过程P调用Q时，会把**返回地址**压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。**把这个返回地址当做P的栈帧的一部分**。**通过寄存器**，过程P可以传递最多**6个**整数值，但是如果Q需要更多的参数，P可以在调用Q之前在栈帧里存储好这些参数。为了提高空间和时间效率，X86-64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。实际上，许多函数甚至根本不需要栈帧。当所有局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数，就可以这样处理。

在x86-64机器中，call Q调用过程Q。该指令会把**地址A**（**返回地址**）压入栈中，并将PC设置为Q的起始地址。对应的指令ret会从栈中弹出地址A，并将PC设置为A

x86-64中，可以通过寄存器最多传递6个整型参数。如果一个函数有大于6个整型参数，超过6个的部分就要通过栈传递。通过栈传递参数时，所有的数据大小都向8的倍数的对齐。

![image-20211127112523692](C:\Users\dmzc\Desktop\Learing\os\images\23.png)

栈上的局部存储，**TODO:什么时候会被分配**

寄存器组是唯一被所有过程共享的资源。虽然给定时刻只有一个过程是活动的，必须确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86_64采用了一组统一的寄存器**使用惯例**，所有过程调用都必须遵循。

根据**惯例**：

* 寄存器**%rbx、%rbp和%r12~%r15**被划为**被调用者保存寄存器**。当过程P调用Q时，Q必须保存这些寄存器的值。针对这些寄存器，在栈帧中创建标号为”保存的寄存器“的一部分。
* 所有其他寄存器，除了栈指针%rsp，都分类为**调用者保存寄存器**，这意味着任何函数都能修改它。过程P在某个此类寄存器中有局部数据，然后调用过程Q，过程Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是**P**(调用者)的责任。

递归过程  **TODO**:分析此过程中例子的汇编代码和对应的函数代码，熟悉过程调用的过程。

###### 数组分配和访问

数组的运算类似于mov指令计算源地址**TODO**

**指针运算：**&、*，取地址，从地址取值

![image-20211127120040111](C:\Users\dmzc\Desktop\Learing\os\images\24.png)

**异质的数据结构**:c语言提供了两种不同类型的对象组合到一起创建数据类型的机制：结构-struct，将多个对象集合到一个单位中；联合-union，允许用几种不同的类型来引用一个对象。

* 结构，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令的位移。
* 联合，类似ts中|

数据对齐：许多计算机系统对基本数据类型和合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K（通常2或4或8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。

对应大多数x86-64指令，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据没有对齐，某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令，就无法正常执行。这些指令对16字节数据块进行操作，在SSE单元和内存之间传输数据的指令要求内存地址必须是16的倍数。较近版本的的x86-64处理器实现了**AVX多媒体指令**，提供了SSE指令的超集，支持AVX的指令并没有强制性的对齐要求。

指针是C语言的一个核心特色。以一种统一的方式，对不同数据结构中的元素产生引用。指针映射到机器代码的关键原则：

* 每个指针都有一个类型
* 每个指针都有一个值，这个值是某个指定类型的对象的地址
* 指针用'&'运算符创建。这个运算符可以应用到任何lvalue类的C表达式上。
* *操作符间接引用指针，是用内存引用来实现的。
* 数组和指针关系密切，一个数组名字可以像一个指针变量一样引用。
* 将指针从一种类型强制转换为另一种类型，之改变类型，不改变值。
* 指针也可以指向函数，这提供一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的其他部分调用。

**GDB、DDD**  **TODO：**

###### 内存越界引用和缓冲区溢出

c对于数组引用不进行任何边界检查，一种常见的状态破坏称为**缓冲区溢出**。

缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。

在一种攻击形式中，攻击代码会使用系统调用启动一个shell程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行ret命令。

###### 对抗缓冲区的溢出攻击

现代的编译器和操作系统实现了很多机制，避免溢出攻击，以下最新GCC提供的机制

* 栈随机化。为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。**安全单一化**。栈随机化的思想：使得栈的位置在程序每次运行时都有变化。因此，既是许多机器都运行同样的代码，它们的地址都是不同的。实现方式：程序开始时，在栈上分配一段0~n字节之间的随机大小的空间。**在linux系统上，栈随机化已经变成标准行为**（是更大的一类技术中的一种，这类技术称为*地址空间布局随机化* **ASLR**）。采用**ASLR**，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。
* 栈破坏检测。最新的GCC代码加入了一种**栈保护者**机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个canary值，程序每次运行时随机生成。在恢复寄存器状态和从函数返回之前，程序检查这个值是否被改变，如果被改变则终止。
* 限制可执行代码区域。限制那些内存区域能够存放可执行代码。典型的程序中，只有保存到编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。硬件支持多种形式的内存保护能够指明用户程序和操作系统内核所允许的访问形式。AMD为其内存保护引入了“NX”位，将读和执行访问模式分来。

###### 浮点代码

处理器的**浮点体系结构**包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上：**TODO:**

* 如何存储和访问浮点值。通常是通过某种寄存器方式完成
* 对浮点数据操作的指令
* 向函数传递浮点数参数和从函数返回浮点数结果的规则
* 函数调用过程中保存寄存器的规则

##### 处理器体系架构 TODO:

现代微处理器可以称的上是人类创造出的最复杂的系统之一。一块指甲大小的硅片上，可以容纳一个完整的高性能处理器、大的高速缓存，以及用来链接到外部设备的逻辑电路。一个处理器支持的指令和指令的字节级编码称为它的**指令集体系结构**（Instruction-Set Architecture,**ISA**）

现代处理器的实际工作方式可能跟ISA隐含的计算模型大相径庭

**优化程序性能TODO：**

编写高效程序：必须选择一组适当的算法和数据结构；必须编写出编译器能够有效优化一转换成高效可执行代码的源代码。理解优化编译器的能力和局限性很重要。

程序优化的第一步就是消除不必要的工作，让代码尽可能有效执行所期望的任务。这包括消除不必要的函数调用、条件测试和内存引用。这些优化不依赖于目标机器的任何具体属性。

为了使程序性能最大化，程序员和编译器都需要一个目标机器的模型，指明如何处理指令，以及各个操作的时序特性。

**存储器层次架构**

存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构。

如果程序需要的数据是存储在CPU寄存器中，那么在指令执行期间，**0个周期**就能访问到；如果存储在高速缓存，需要**4~75个**周期；如果存储在主存中，需要**上百个**周期；如果存储在磁盘，需要**几千万**周期

具有良好局部性的程序倾向于一次又一次的访问相同相同的数据项集合，或是倾向于访问邻近的数据项集合。具有良好局部性的程序比局部性差的程序更多的倾向于从存储器层次结构中较高层次处访问数据项。

###### 随机访问存储器（RAM）

RAM分为两类，静态RAM（**SRAM**）比动态RAM（**DRAM**）更快，但也贵得多。**SRAM**用来作为高速缓存存储器，既可以在CPU芯片上，也可以在片下。DRAM用来作为主存以及图形系统的帧缓冲区。典型的，一个桌面系统的**SRAM**不会超过几M字节，但是**DRAM**却有几百或几千M字节。

**SRAM：**

将每个位存储在一个双稳态的存储器单元里。每个单元用一个六晶体管电路实现（**TODO:**）。由于双稳态，只要有电，他就永远保持它的值。即使有干扰来扰乱电压，当干扰消除时，电路就会恢复到稳定值。

**DRAM:**

将每个位存储为对一个电容的充电。DRAM存储器可以制造的非常密集--每个单元由一个电容和一个访问晶体管组成。DRAM存储器单元对干扰非常敏感，电容的电压被扰乱之后，就永远不会恢复。很多原因会导致漏电，使得**DRAM**单元在10~100毫秒时间内失去电荷。内存系统必须周期性的通过读出，然后重写刷新每一位。有的系统也使用纠错码，其中计算机的字会被多编码几个位，这样电路可以发现并纠正一个字中任何单个的错误位。

![image-20211130225640495](C:\Users\dmzc\Desktop\Learing\os\images\25.png)

<img src="C:\Users\dmzc\Desktop\Learing\os\images\26.png" alt="image-20211130230609401" style="zoom:67%;" />

每个DRAM芯片被连接到某个称为***内存控制器***的电路，这个电路可以一次传送w位到每个DRAM芯片或者一次从每个DRAM芯片传出w位。为了读出超单元(i，j)的内容，内存控制器将行地址i发送到DRAM，然后就是列地址j。DRAM把超单元(i,j)发回控制器作为响应。行地址称为RAS（Row Access Stroble）请求，列地址j称为CAS。RAS、CAS请求共享相同的DRAM地址引脚。

电路设计者将DRAM组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。二位阵列组织的缺点是必须分两步发送地址，增加了访问时间。

DRAM芯片封装在**内存模块**中，它插在主板的扩展槽

###### 增强的DRAM

* 快页模式DRAM（**FPM**），传统的DRAM将超单元的一整行复制到它内部缓冲行缓冲区，使用一个，然后丢弃剩余的。FPM DRAM则允许对同一行连续访问使用同一个行缓存
* 扩展数据输出DRAM（**EDO**），FPM的一个增强的形式，允许各个CAS信号在时间上靠得更紧密点
* 同步DRAM（**SDRAM**）。常规的、FPM和EDO DRAM都是异步的。SDRAM用与驱动内存控制器相同的外部时钟信号的上升沿来代替许多这样的控制信号。
* 双倍速率同步DRAM（**DDR DRAM**）,是对SDRAM的一种增强，通过使用两个时钟沿作为控制信号，是DRAM速率翻倍。不同类型的DDR SDRAM是用提高有效带宽的很小的预取缓冲区的大小来划分的：DDR(2位)、DDR2(4位)、DDR(8位)。
* 视频RAM（**VRAM**），用在图形系统的帧缓冲区中。与FPM思想类似。

![image-20211130233702153](C:\Users\dmzc\Desktop\Learing\os\images\27.png)

**TODO:现有的DRAM发展**

###### 非易失性存储器

由于历史原因，虽然ROM中有的类型既可以读也可以写，但它们整体都被称为只读存储器。ROM是以它们能够被重编程（写）的次数和对它们进行重编程所用的机制区分的。

[为什么SRAM比DRAM快？ (qastack.cn)](https://qastack.cn/superuser/648370/why-is-sram-faster-than-dram)

* PROM（可编程ROM）只能被编程一次。PROM的每个存储器单元有一种熔丝，只能用高电流熔断一次。
* EPROM（可擦写可编程），有一个透明的石英窗口，允许到达存储单元。紫外线光照射过窗口，EPROM单元就被存储为0。对EPROM编程是通过使用一种把1写入到EPROM的特殊设备完成的。EPROM能够被擦除和重编程的次数的数量级可以达到1000次。EEPROM（电子可擦除PROM）类似于EPROM，但是它不需要一个物理上独立的编程设备，因此可以直接在印刷电路卡上编程。能够被编程的次数的数量级可以达到10的5次方。
* 闪存（flash memory）,基于EEPROM，已经成为一种重要的存储技术，为大量的电子设备提供快速而持久的非易失性存储，包括数码相机、手机、音乐播放器、PDA和笔记本。

存储在ROM设备中的程序通常称为固件

数据流通过称为总线的共享电子电路在处理器的和DRAM主存之间来回。每次CPU和主存之间的数据传送都是通过一系列步骤完成，这些步骤称为***总线事务***。

***读事务***从主存传送数据到CPU，***写事务***从CPU传送数据到主存。

总线是一组并行的导线，能携带地址、数据和控制信号。取决于总线的设计，数据和地址信号可以共享同一组导线，也可以使用不同的。同时，两个以上的设备也能共享同一总线。***控制线***携带的信号会同步事务，并标识出当前正在执行的事务的类型。

![image-20211201215930939](C:\Users\dmzc\Desktop\Learing\os\images\28.png)

###### 磁盘存储

磁盘由**盘片**构成，每个盘片由两面，表面覆盖磁性记录材料。盘片中央有一个可以旋转的主轴。它使盘片以固定的***旋转速率***旋转，通常是5400~15000转没分钟。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器。

**磁盘寻道算法TODO：**

磁盘构造复杂，有多个盘面，盘面上有不同的记录区。为了隐藏复杂的构造，现代磁盘将它们的构造呈现为一个简单的视图：一个B个扇区大小的逻辑块。硬盘中封装有一个小的**硬件/固件设备**，称为**磁盘控制器**，维护着逻辑块号和实际（物理）磁盘之间的映射关系。

到OS想要执行一个IO操作时，例如读一个磁盘扇区的数据到主存，操作系统会发送一个命令到**磁盘控制器**，让它读某个**逻辑块号**。控制器上的**固件**执行一个快速表查找，将一个逻辑块块号翻译成一个（盘面，磁道，扇区的三元组，这个三元组唯一标识了对应的物理扇区）。控制器上的硬件会解释这个三元组，将**读/写头**移动到适当的柱面，等待扇区移动到读/写头下，将读/写头感知到的位放到控制器的一个缓冲区，然后复制到主存。

**格式化磁盘：**用标识扇区的信息填写扇区之间的间隙，标识出表面有故障的柱面并且不在使用它们，以及为每个区中预留一组柱面作为备用，如果一个区中一个或多个柱面在磁盘使用的过程中坏掉，就可以使用备用柱面。

###### IO设备

例如图形卡、监视器、鼠标和磁盘这样IO设备，都是通过I/O总线连接到CPU和主存。

![image-20211201223851076](C:\Users\dmzc\Desktop\Learing\os\images\29.png)

例如Intel的外围设备互连（PCI）总线连接到CPU和主存的。**系统总线**、**内存总线**是与CPU相关的，与它们不同，诸如**PCI这样的I/O总线**设计成与底层CPU无关。

虽然I/O总线比系统总线和内存总线慢，但是可以容纳种类繁杂的第三方I/O设备。其中：

* 通用串行总线（USB）控制器是一个连接到USB设备的中转机构，USB总线是一个广泛使用的标准，连接各种外围I/O设备，包括键盘、鼠标、调制解调器、数码相机、游戏操纵杆、打印机、外部磁盘驱动器和固态硬盘。USB3.0总线的最大带宽为625MB/s,USB3.1总线的最大带宽为1250MB/s.
* 主机总线适配器将一个或多个磁盘连接到I/O总线，使用的是一个特别的**主机总线接口**定义的通信协议。两个最常用的这样的磁盘接口是SCSI和SATA。

![image-20211201230422586](C:\Users\dmzc\Desktop\Learing\os\images\30.png)

CPU使用一种称为**内存映射I/O**的技术来向**I/O设备**发射命令。在使用内存映射I/O的系统中，地址空间中有一块是为与I/O设备通信保留的。每个这样的地址称为一个I/O端口。当一个设备连接到总线时，它与一个或多个端口相关联。

假设磁盘控制器映射到端口0xa0。随后，CPU可能通过执行三个对地址0xa0的存储指令，发起磁盘读：第一条指令发送一个命令字，告诉磁盘发起一个读，同时还发送其他参数，例如当读完成后，是否中断CPU。第二条指令指明应该读的逻辑块。第三条指令指明应该存储磁盘扇区内容的主存地址。

当CPU发出了请求之后，在磁盘执行读的时候，通常会做其他的工作。一个1GHz的处理器时钟周期为1ns，在用来读磁盘的16ms时间里，它潜在地可能执行1600万条指令。在磁盘控制器接受到来自CPU的读命令之后，将逻辑块地址翻译成一个扇区地址，读该扇区的内容，然后将这些内容直接传送到主存，不需要CPU的干涉。**设备可以以自己执行读或写总线事务而不需要CPU干涉的过程，称为*直接内存访问(DMA)***

**为什么有DMA，什么场景下出现的DMA，DMA解决什么问题？？？TODO：**

DMA传送完成后，磁盘控制器给CPU发送中断信号来通知CPU.基本思想是中断会发信号到CPU芯片的一个外部引脚上。这会导致CPU暂停它正在做的工作，跳转到操作系统例程，这个操作会记录I/O已完成，然后控制返回到CPU中断的地方。

**为什么会有时钟周期的概念TODO:**

###### 固态硬盘

一种基于闪存的技术

![image-20211201233736573](C:\Users\dmzc\Desktop\Learing\os\images\31.png)

一个SDD封装由一个或多个**闪存芯片**和**内存翻译层**组成，**内存芯片**替代传统旋转盘中的机械驱动器，而**闪存翻译层**是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的请求翻译成对底层物理设备的访问。

一个闪存由B个块的序列组成，每个块由p页组成。通常页的大小是512字节~4KB，块由32~128页组成。块的大小为16kb~512kb。数据是以页为单位写的。只有在一页所属的块整个被擦除后，才能写这一页。进行约100000次重复写之后，块就会磨损

随机写很慢，擦除块需要相对较长时间，1ms级，比访问页所需时间高一个数量级；如果写操作视图修改一个包含已经有数据的页p，那么这个块中所有带有用数据的页都必须被复制到一个新的块，然后才能进行对页p的写。

**SSD和旋转磁盘的对比TODO：**

###### 存储技术趋势

###### 局部性：

在一个具有良好**时间局部性**的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。在一个具有良好**空间局部性**的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。

**缓存TODO:**

##### 链接

*链接*是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。

*链接*可以**执行于编译时**，也就是在源代码被翻译成机器代码时；也可以**执行于加载时**，也就是程序被加载器加载到内存并执行时；甚至**执行于运行时**，也就是由应用程序来执行。早期计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做**链接器**的程序自动执行的。

链接器使得**分离编译**（类似模块化）成为可能，不用将一个大型的程序组织成一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立修改和编译这些模块。

* 理解链接器帮助你构造大型程序，构造大型程序时经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的链接器错误。
* 理解编译器将帮助你避免一些编程错误。linux链接器解析符号引用时所做的决定可以不动声色地影响你程序的正确性。
* 理解链接将帮助你理解语言的作用域规则是如何实现的。
* 理解链接将帮助你理解其他重要的系统概念。链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色，比如加载和运行程序、虚拟内存、分页、内存映射。
* 理解链接使你能够利用共享库。随着共享库和动态链接在现代操作系统中的重要性日益加强，链接成为一个复杂的过程。例，许多软件产品在运行时使用共享库来升级压缩包装的二进制程序。大多数web服务器都依赖于共享库的动态链接来提供动态内容。

大多数编译系统提供**编译器驱动程序**，它代表用户在需要时调用预处理器、编译器、汇编器和链接器。

像**linux ld**程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载运行的可执行目标问价作为输出。输入的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列。为了构造可执行文件，链接器必须完成两个任务：

* 符号解析。目标文件定义和引用符号，每个符号对应于一个函数、一个全局函数变量或一个静态变量。符号解析的目的是将每个**符号引用**正好和一个**符号定义关联**起来
* 重定位。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而**重定位**这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的**重定位条目**的详细指令，不加甄别的执行这样的重定位。

目标文件存粹是字节块的集合，这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含**引导链接器和加载的数据结构**。链接器将这些块链接起来，确定被链接块的运行时位置，并且修改代码和数据块中的各种位置。

**目标文件**

三种形式：

* 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来。
* 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存执行。
* 共享目标文件。一种特殊类型的可重定位目标文件，可以加载或者运行时被动态加载进内存并链接。

可重定位目标文件：

![image-20211204194718918](C:\Users\dmzc\Desktop\Learing\os\images\32.png)

* ELF头，以一个**16字节的序列**开始的，这个**16字节序列**生成了该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含了帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型、机器类型、**节头部表的文件偏移**以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。ELF头和节头部表之间都是节
* 典型ELF可重定位目标文件包含下面几个节：
  * .text,已编译程序的机器代码
  * .rodata,只读数据，比如printf语句中的格式串和开关语句的跳转表
  * .data，已初始化的全局和静态C变量
  * .bbs（**Block Started By Symbol**）,未初始化的静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中，这个节不占据实际的空间，仅仅是一个占位符。目标文件区分已初始化和未初始化变量是为了**空间效率**：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间，运行时，在内存中分配这些变量，初始值为0
  * .symtab，符号表，存放程序中定义和引用的函数和全局变量的信息。每个可重定位目标文件在.symtab中都有一张符号表。和编译器中的符号表不同，不包含局部变量的条目。
  * .rel.text：一个.text节中的位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般，任何调用外部函数或者引用全局变量的指令都需要修改。调用本地函数的指令不需要修改。
  * .rel.data:被模块引用的或定义的所有全局变量的重定位信息。一般，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或外部定义函数的地址，都需要修改。
  * .debug:符号调试表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件，只有-g编译时，才包括这个表。
  * .line:原始C源程序中的行号和.text节中的机器指令之间的映射，只有-g才会得到这张表
  * .strtab,一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。

每个可重定位目标模块m都有一个符号表，包含m定义和引用的的符号的信息。在链接器的上下文中，有三种不同符号：

* 由模块m定义并能被其他模块引用的全局符号，对应于模块m中非静态的C函数和全局变量
* 由其他模块定义被被模块m引用的全局符号，对应于其他模块中的非静态的C函数和全局变量
* 只被模块m定义和引用的局部符号。对应于带static属性的函数和全局变量，这些符号在模块m中任何位置可见，但是不能被其他模块引用

.symtab不包含对应于本地非静态程序变量的任何符号。但是定义带有C static属性的本地过程变量是不再栈中管理的。相反，编译器在.data或.bbs中为每个定义分配空间，并在符号表创建一个有唯一名字的本地链接器符号。

```
typedef struct{
	int name;//String table offset
	char type:4,//Fuction or Data
		 binding:4;//Local or global
	char reserved;//unsed
	short section;//section header index
	long value;//section offset or absolute address
	long size;//Object size in bytes
} ELF64_Symbol;
```

name表示字符串表中的字节偏移，指向符号的以null结尾的字符串名字。value是符号的地址，对于可重定位的模块来说，value是距定义目标的节的起始位置的偏移，对于可执行文件来说，是一个绝对运行时地址。

每个符号都被分配到目标文件的某个节，有setion字段表示，该字段也是一个到节头表的索引。有三个特殊的伪节，在节头部表是没有条目的：ABS代表不该被重定位的符号；UNDEF代表未定义的符号，也就是在本目标模块中引用，但是在其他地方定义的符号；COMMON表示还未被分配位置的未初始化的数据目标。对于COMMON符号，value字段给出了对齐要求，只有可重定位文件才有这些伪节。

链接器解析符号引用，Linux编译系统处理多个同名全局符号

编译时，编译器向汇编器输出每个全局符号，强或弱。汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。

根据强、弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：

* 不允许有多个同名的强符号
* 如果有一个强符号和多个弱符号同名，那么选择强符号
* 如果多个弱符号同名，那么从弱符号中任意选择一个

**与静态库链接：**

所有编译系统，都提供一种机制，将所有相关的目标文件打包成为一个单独的文件，成为**静态库**，它可以用作链接器的输入，当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

如果不使用静态库，编译器开发人员会使用什么方法提供标准函数？

一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码（Pascal），这样，每次添加、删除或修改一个标准函数时，就需要一个新的编译器版本

另一种方法是将所有标准C函数都放在一个单独的可重定位目标模块中，应用程序员可以把这个模块链接到它们的可执行文件中。

静态库：相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态文件。链接时，只复制被程序引用的目标模块。

Linux系统中，静态库以一种成为**存档**的特殊文件格式存放在磁盘。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员文件的大小和位置，存档文件名由后缀.a标识。

ar打包静态库

符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。此次扫描中，链接器维护了一个可重定位目标文件集合E，一个未解析的符号（引用了但尚未定义）集合U，以及一个在前面输入文件中已定义的符号集合D

* 对于每个输入文件f，如果f是一个目标文件，把f添加到E，修改U和D来反映f中符号定义和引用
* 如果f为存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加入到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有成员目标文件都依次进行这个过程，知道U和D都不在发生变化。此时，任何不包含在E中的成员目标文件都简单的被丢弃。
* 如果当链接器完成对命令行的输入文件的扫描之后，U是非空的，那么链接器就会输入一个错误

**重定位**

一旦链接器完成了符号解析，就把代码中的每个符号引用和一个符号定义（.symtab）关联起来。此时，链接器就知道了它的输入模块中代码节和数据节的确切大小，就可以开始重定位：

* 重定位节和符号定义。将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号
* 重定位节中的符号引用。链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行地址。

**重定位条目**

.rel.text   .rel.data

```c
typedef struct{
    long offset;//Offset of the renference to relocate
    long type:32,//Relocation type
    	 symbol：32，//Symbol table index
    long addend;//Constant part of relocation expression
} Elf64_Rela;
```

**重定位TODO:**



























《学完ELF后人间清醒的总结v1.0》

《程序员的自我修养-链接、装载和库》

