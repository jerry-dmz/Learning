《深入理解计算机》

大部分现代计算系统都使用ASCLL标准来表示文本字符，这种方式就是使用一个唯一的单字节大小的整数值来表示每个字符。

hello.c就是以字节序列的方式存储在文件中的。像这种文件称为**文本文件**，所有其他文件都称为**二进制文件**。

hello.c的表示方法说明了一个**基本思想**：系统中所有的信息--磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。

区分不同数据对象的唯一方法是读取这些数据对象时的上下文。**信息 = 位+上下文**

<img src="..\images\5.png" alt="image-20211114000837003" style="zoom: 67%;" />

* 预处理器，将头文件内容真正插入到文件中，通常用i作为扩展名
* 编译阶段，将文本文件hello.i翻译成文本文件hello.s 。为不同语言、不同编译器提供统一的格式
* 汇编阶段，将文本文件hello.s翻译成机器语言指令hello.o，将指令打包成**可重定位目标程序**(relocatable object program)的格式
* 链接阶段，得到hello**可执行文件**

GCC编译器已经发展到支持不同的语言，能够为许多不同的机器生成代码

![image-20211114002127053](..\images\7.png)



**高速缓存至关重要**

![image-20211114002741119](..\images\8.png)

![image-20211114002924377](..\images\9.png)

**虚拟内存：**

为每个进程提供一个假象，即每个进程都在独占的使用主存（**虚拟地址空间**）

<img src="C:\Users\dmzc\Desktop\Learing\os\images\10.png" alt="image-20211114003416341" style="zoom:67%;" />

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。**基本思想是把一个进程虚拟内存的内容存储到磁盘上，然后用主存作为磁盘的告诉缓存**(**ELF**???)

**文件**：

文件就是**字节序列**,它向应用程序提供了一个统一的视图，来看待系统中可能包含的所有各式各样的I/O设备。

**并发与并行**:

* **线程级并发**，多核处理器是将多个CPU("核")集成到一个**集成电路芯片**上，每个核都有自己的**L1和L2高速缓存**；其中L1告诉缓存分为两个部分：

  一个 保存最近取到的指令，另一个存放数据。这些核共享更高层次的**高速缓存L3**，以及到主存的接口。

  <img src="C:\Users\dmzc\Desktop\Learing\os\images\11.png" alt="image-20211114005643002" style="zoom:50%;" />

  **超线程**，**TODO:**一项允许一个CPU执行多个控制流的技术。

* **指令级并行**，早期的微处理器，如**Intel 8086**,需要多个**（3~10个）时钟周期来执行一条指令**。最近的处理器可以保持**每个时钟周期2~4条指令**的执行效率。其实每条指令从开始到结束需要长的多的时间，大约**20个周期**，但是处理器使用了非常多的聪明技巧，将执行一条指令所需要的活动分为不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤,这些阶段可以并行操作，用来处理不同指令的不同部分。

  如果处理器可以达到一个周期一条指令更快的执行速率，就称为**超标量处理器**。大多数现代处理器都支持超标量操作

* **单指令、多数据并行**，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，SIMD。提供这些SIMD指令是为了提高处理影像、声音和视频数据应用的执行速度。

**抽象很重要**：

**文件**是对**I/O设备**的抽象，**虚拟内存**是对**程序存储器**的抽象，**进程**是对一个**正在运行的程序**的抽象，**虚拟机**提供了对整个计算机的抽象，包括操作系统、处理和程序。



##### 信息的表示和处理

对二值信号进行存储和执行计算的电子电路非常简单可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。

整数的表示虽然只能编码一个相对较小的数值范围，但是是精确的。浮点数虽然可以编码一个较大的数值范围，但是只是近似的。

大量的计算机漏洞都是由于计算机算术运算的微妙细节引发的。

C++编程语言建立在C基础之上，它们使用相同的数字表示和运算。java创造了一套新的数字表示和运算标准。

大多数计算机使用8位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。

为了避免由于依赖“典型”大小和不同编译器设置带来的行为，ISO C99引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型int32_t和int64_t,分别为4个字节和8个字节。

对于跨越多字节的程序对象的寻址，这个对象地址是什么，以及如何在内存中排列这些对象（大端法、小端法）

大多数Intel兼容机都只用小端模式。另一方面，IBM和Oracle的大多数机器则是按大端模式操作。许多比较新的微处理器是双端法，可以把他们配置成作为大端或者小端的机器运行。

二进制很少能在不同机器和操作系统组合之间移植。从机器角度，程序仅仅是字节序列，机器没有任何关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

##### **程序的机器级表示**

**8086**（1978年，**29k**），是第一代单芯片、16位微处理器之一。8088是8086的一个变种，在8086的基础上增加了一个8位外部总线

**80286**（1982年，**134k**），增加了更多寻址模式

**i386**(1985年，**275K**)，将体系结构**扩展到32位**

**i486**(1989年，**1.2M**)，改善了性能，同时将**浮点单元集成到处理器芯片**，但是指令集没有明显变化

**Pentium**(1993,**3.1M**)，改善了性能，对指令集进行了小的扩展

**PentiumPro**(1995，**5.5M**）,引入了**全新的处理器设计**，在内部被称为**P6**微体系架构。指令集内增加一类“条件传送”指令

**Pentium/MMX**(1997，**4.5M**）,在Pentium处理器中增加了一类新的处理整数向量的指令。**TODO:**

**Pentium  II**(1997，**7M**）,**p6**微体系架构的延伸

**Pentium III**(1999，**8.2M**）,引入了SSE，这是一类处理整数或浮点数向量的指令

**Pentium 4**(2000，**42M**）,SSE扩展到SSE2

**Pentium 4E**(2004，**125M**）,增加了**超线程**，这种技术可以在一个处理器上同时运行两个程序；增加了**EM64T**，它是Intel对AMD提出的对IA32的64扩展的实现，称之为**x86_64**

**Core2**(2006,**291M**),**回归**到类似**P6**的微体系架构。Intel的**第一个多核微处理器**，不支持超线程

.......

gcc -Og告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。

对于机器级编程，两种抽象最为重要。**第一种**，指令集体系结构(**ISA**)来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响；大多数ISA，包括x86-64,将程序的行为描述成好像每条指令都是按顺序执行的；处理器的硬件远比描述的精细复杂。**第二种**，机器级程序使用的是内存地址是**虚拟地址**。

x86-64的机器代码和原始的C代码差别很大，一些通常对C隐藏的处理器状态都是可见的：

* PC，x86-64中用%rip表示
* 整数寄存器包含16个命名的位置，分别存储64位的位置。这些寄存器可以存储的地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程中的参数和局部变量，以及函数的返回值。
* 条件码寄存器保存最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件变化。
* 一组向量寄存器，可以存放一个或多个整数或浮点数值

程序内存包含：程序可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。程序内存用**虚拟地址**寻址，操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

一条机器指令只执行一个非常基本的操作。例如，将两个寄存器的数字进行加减，在存储器和寄存器之间传输数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令序列，从而实现类似C语言的程序结构。

**objdump -d，反汇编**

* x86-64的指令长度从1到15个字节不等
* 设计指令格式的方式，从某个给定的位置开始，可以将字节唯一的解码为机器指令。pushq %rbx是以值53开头的。
* 反汇编器只是基于机器文件中的字节序利来确定汇编代码
* 反汇编器使用的指令命名规则于GCC生成的汇编使用有细微差别

ATT是GCC、OBJDUMP和其他一些使用工具的默认汇编格式。其他一些编程工具，包括微软，以及Intel的文档，其汇编代码都是Intel格式的。

在C程序中插入汇编代码：

* 编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和C语言书写的代码合并
* 使用GCC内联汇编特性，用asm伪指令可以在C程序中包含简短的汇编代码

Intel用术语，字(word)-16位，双字(double words)-32位，四字(quad words)-64位

![image-20211114151319595](C:\Users\dmzc\Desktop\Learing\os\images\12.png)

<img src="C:\Users\dmzc\Desktop\Learing\os\images\13.png" alt="image-20211114161903659" style="zoom: 80%;" />

8086有8个16位的寄存器，即%ax~%sp；扩展到IA32架构时，8个通用寄存扩展成32位，%eax~%esp；x86-64后，原来的8个寄存器扩展成了64位，%rax`%rsp,此外还增加了8个新的寄存器，%r8~%r15

如图中的方框标明的，指令可以对16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器

少量指令会使用特定的寄存器。更重要的是，**有一组标准的编程规范**控制着如何使用寄存器来管理栈、传递函数参数、从函数返回值，以及存储局部和临时数据。

**操作数指示符**：

大多数指令有一个或多个**操作数**，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据值可以用**常数形式**给出，或者是从寄存器或内存中读出。结果可以存放到寄存器或内存中。

<img src="C:\Users\dmzc\Desktop\Learing\os\images\14.png" alt="image-20211114163624891"  />



* 数据传送指令：movb、movw、movl、movq,源操作数指定的值是一个立即值，存储在寄存器中或者内存中，目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址，x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。大多数情况下，mov指令以寄存器作为目的时，只会更新目的操作数指定的那些寄存器或内存位置。唯一的例外，movl指令以寄存器作为目的时，会把寄存器的高位4字节置为0,x86-64的惯例。

  ![image-20211115220653502](C:\Users\dmzc\Desktop\Learing\os\images\15.png)

  movabsq指令能够以任意64位立即数值作为源操作数

  <img src="C:\Users\dmzc\Desktop\Learing\os\images\16.png" alt="image-20211115221023562" style="zoom:80%;" />

* 压栈和弹栈指令，pushq、popq

![image-20211120171107070](C:\Users\dmzc\Desktop\Learing\os\images\17.png)

* 加载有效地址，leaq，将有效地址写入到目的地，如leaq (%rdi,%rsi,4),%rax（其中rdi=x,rsi=y,rax=z）,则为z=x+4*y

* 一元和二元操作，x++,y-=1,一元操作只有一个操作数，既是源又是目的，可以是一个寄存器，也可以是内存位置；二元操作，第二个操作数既是源，又是目的，源操作数是第一个，第一个操作数可以是立即数、寄存器或内存位置，第二个操作数可以是寄存器或内存位置。如果第二个操作数为内存，处理器必须从内存中读出值，进行操作，最后把结果写回内存。

* 移位操作，移位量可以是一个立即数，或者放在单字节寄存器%cl中

* 特殊算术操作

  ![image-20211120185913156](C:\Users\dmzc\Desktop\Learing\os\images\18.png)

机器代码提供两种基本的低级机制来实现有条件的行为：**测试数据值**  **根据测试的结果来改变控制流或数据流**

* 条件码，除了整数寄存器，CPU还维护着一组单个位的条件码寄存器，用于描述最近的算术或逻辑操作的属性。还可以检测这些寄存器来执行条件分支指令。

  CF：进位标志。最近的操作使最高位了进位。可用来检查无符号操作的溢出

  ZF：零标志。最近的操作得出的结果为0

  SF:符号标志。最近的操作得到的结果为负数

  OF：溢出标志。最近的操作导致一个补码溢出

  leaq指令不会改变任何条件码，因为它是用来进行地址计算的。对于逻辑操作，进位标志和溢出标志会设置为0。对于移位操作，进位标志将设置为最后一个被移出的位。inc、dec会设置溢出和零标志，但是不会改变进位标志。

  除了指令的副作用会设置条件码。还有两类指令，只设置条件码而不改变任何其他寄存器。CMP会根据两个操作数之差来设置条件码。TEST指令会根据两个操作数之和设置条件码。

* 访问条件码，条件码通常不会直接读取；可以根据条件码的某种组合，将一个字节设置位0或者1；可以条件跳转到程序的某个其他部分；可以有条件的传送数据。

  一条SET指令的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置为0或1.

  ![image-20211120192518431](C:\Users\dmzc\Desktop\Learing\os\images\19.png)

  某些底层的机器指令可能有多个名字，称为“同义名”。setg("设置大于")和setnle("设置不小于等于")，指的是同一条机器指令，编译器和反汇编器会随意决定使用哪个名字

* 跳转指令，产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标编码为跳转指令的一部分

![image-20211120193436495](C:\Users\dmzc\Desktop\Learing\os\images\20.png)

当执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的指令

rep后面跟ret的组合是为了避免使ret指令称为条件跳转指令的目标。

**条件控制实现条件分支**

![image-20211120195027661](C:\Users\dmzc\Desktop\Learing\os\images\21.png)



**条件传送实现条件分支**

实现条件操作的传统方法是通过使用**控制**的**条件转移**。当条件满足时，程序沿着一条分路执行路径执行，当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，可能非常低效。

一种可替代的策略是使用“**数据的条件转移**”**TODO:**

**循环**：基于控制的条件转移

**switch**：跳转表

**过程**

过程是软件中一种很重要的抽象。提供一种封装代码的方式，用一组指定的参数和一个可选的返回值实现某种功能。然后在程序中不同的地方调用这个函数。

设计良好的软件用过程作为抽象机制，隐藏某个实现的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是那些值，过程会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：函数、方法、子例程、处理函数等，但都有一些共同的特性：

*传递控制*：进入过程Q时，PC必须被设置为Q的代码起始地址，返回时，要把PC设置为P中调用Q后面那条指令的地址。

*传递数据*：P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。

*分配和释放内存* ：开始时，Q可能为局部变量分配空间，而在返回前，又必须释放这些存储空间。

X86-64的**过程实现**包括一组特殊指令和一些对机器资源（例如寄存器和程序内存）使用的约定规则。

<img src="C:\Users\dmzc\Desktop\Learing\os\images\22.png" alt="image-20211125212137671" style="zoom: 80%;" />

x86-64的栈向低地址方向增长，而栈指针%rsp指向栈顶元素。当x86-64过程需要的存储空间超过寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧。当过程P调用Q时，会把**返回地址**压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。**把这个返回地址当做P的栈帧的一部分**。**通过寄存器**，过程P可以传递最多**6个**整数值，但是如果Q需要更多的参数，P可以在调用Q之前在栈帧里存储好这些参数。为了提高空间和时间效率，X86-64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。实际上，许多函数甚至根本不需要栈帧。当所有局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数，就可以这样处理。

在x86-64机器中，call Q调用过程Q。该指令会把**地址A**（**返回地址**）压入栈中，并将PC设置为Q的起始地址。对应的指令ret会从栈中弹出地址A，并将PC设置为A

x86-64中，可以通过寄存器最多传递6个整型参数。如果一个函数有大于6个整型参数，超过6个的部分就要通过栈传递。通过栈传递参数时，所有的数据大小都向8的倍数的对齐。

![image-20211127112523692](C:\Users\dmzc\Desktop\Learing\os\images\23.png)

栈上的局部存储，**TODO:什么时候会被分配**

寄存器组是唯一被所有过程共享的资源。虽然给定时刻只有一个过程是活动的，必须确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86_64采用了一组统一的寄存器**使用惯例**，所有过程调用都必须遵循。

根据**惯例**：

* 寄存器**%rbx、%rbp和%r12~%r15**被划为**被调用者保存寄存器**。当过程P调用Q时，Q必须保存这些寄存器的值。针对这些寄存器，在栈帧中创建标号为”保存的寄存器“的一部分。
* 所有其他寄存器，除了栈指针%rsp，都分类为**调用者保存寄存器**，这意味着任何函数都能修改它。过程P在某个此类寄存器中有局部数据，然后调用过程Q，过程Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是**P**(调用者)的责任。

递归过程  **TODO**:分析此过程中例子的汇编代码和对应的函数代码，熟悉过程调用的过程。

###### 数组分配和访问

数组的运算类似于mov指令计算源地址**TODO**

**指针运算：**&、*，取地址，从地址取值

![image-20211127120040111](C:\Users\dmzc\Desktop\Learing\os\images\24.png)

**异质的数据结构**:c语言提供了两种不同类型的对象组合到一起创建数据类型的机制：结构-struct，将多个对象集合到一个单位中；联合-union，允许用几种不同的类型来引用一个对象。

* 结构，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令的位移。
* 联合，类似ts中|

数据对齐：许多计算机系统对基本数据类型和合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K（通常2或4或8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。

对应大多数x86-64指令，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据没有对齐，某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令，就无法正常执行。这些指令对16字节数据块进行操作，在SSE单元和内存之间传输数据的指令要求内存地址必须是16的倍数。较近版本的的x86-64处理器实现了**AVX多媒体指令**，提供了SSE指令的超集，支持AVX的指令并没有强制性的对齐要求。

指针是C语言的一个核心特色。以一种统一的方式，对不同数据结构中的元素产生引用。指针映射到机器代码的关键原则：

* 每个指针都有一个类型
* 每个指针都有一个值，这个值是某个指定类型的对象的地址
* 指针用'&'运算符创建。这个运算符可以应用到任何lvalue类的C表达式上。
* *操作符间接引用指针，是用内存引用来实现的。
* 数组和指针关系密切，一个数组名字可以像一个指针变量一样引用。
* 将指针从一种类型强制转换为另一种类型，之改变类型，不改变值。
* 指针也可以指向函数，这提供一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的其他部分调用。

**GDB、DDD**  **TODO：**

###### 内存越界引用和缓冲区溢出

c对于数组引用不进行任何边界检查，一种常见的状态破坏称为**缓冲区溢出**。

缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。

在一种攻击形式中，攻击代码会使用系统调用启动一个shell程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行ret命令。

###### 对抗缓冲区的溢出攻击

现代的编译器和操作系统实现了很多机制，避免溢出攻击，以下最新GCC提供的机制

* 栈随机化。为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。**安全单一化**。栈随机化的思想：使得栈的位置在程序每次运行时都有变化。因此，既是许多机器都运行同样的代码，它们的地址都是不同的。实现方式：程序开始时，在栈上分配一段0~n字节之间的随机大小的空间。在linux系统上，栈随机化已经变成
* 

















《学完ELF后人间清醒的总结v1.0》

《程序员的自我修养-链接、装载和库》

