《汇编语言-王爽》

**实现部分可以专门留在后面**

汇编语言由以下3类指令组成：

* 汇编指令：机器码的助记符，有对应的机器码
* 伪指令：没有对应机器码，由编译器执行，计算器不执行
* 其他符号：如+、-、*等，由编译器识别，没有对应机器码

CPU要想进行数据的读写，必须和外部器件有以下3类交互：

* 存储单元的地址（地址信息）
* 器件的选择，读或写的命令（控制信息）
* 读或写的数据（数据信息）

CPU从内存3号单元读取内容：

* 通过**地址线**将地址信息3发出
* 通过**控制线**发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据
* 存储器将3单元中的数据通过**数据线**送入CPU

CPU对外部器件的控制是通过控制总线进行的。**控制总线**是一些不同控制线的集合。有多少根控制总线，就代表CPU提供了对外部器件的多少种控制。

CPU可以用不同的段地址和偏移地址形成一个同一个物理地址

8086CPU加电启动或复位后，CS和IP被设置为CS=FFFFH，IP=0000H

mov指令可以修改通用寄存器的值，但是不能用来修改CS、IP的值。能够改变CS、IP内容的指令被统称为转移指令

mov指令支持的格式：（TODO:）

```assembly
mov 寄存器，数据
mov 寄存器，寄存器
mov 寄存器，内存单元
mov 内存单元，寄存器
mov 段寄存器，寄存器
mov 寄存器，段寄存器
//可以将直接数、寄存器、内存单元传送到通用寄存器
//可以将寄存器内容传送到内存单元、段寄存器
```

8086CPU不支持将数据直接送到段寄存器

现今的CPU中都有栈的设计，**任意时刻SS:SP指向栈顶元素**

现代CPU如何保证栈不会越界呢？TODO:

mov  ax,[bx]   把内存中的一个地址送到ax，偏移地址在ds:bx

loop指令：执行此指令时进行两步操作，cx=cx-1,cx值不为0则转至标号处执行程序，如果为0则向下执行

**段前缀**：

mov ax,cs:[0]

这些出现在访问内存单元的指令中，用于显式地指明内存单元地段地址地“ds:”,"cs:","ss:","es:",在汇编语言中称为段前缀，默认为ds

在纯DOS方式（实模式）下，没有能力对硬件系统进行全面、严格地管理。DOS方式下，DOS和其他合法程序一般都不会使用**0:200~0:2ff**地256个字节的空间。

在操作系统环境中，合法通过操作系统获取的空间都是安全的，因为操作系统不会让一个程序所用的空间和其他程序以及系统自己的空间相冲突。

程序取得空间的方法有两种，一种是在加载程序的时候为程序分配，在就是程序在执行过程中像系统申请。

汇编语言伪指令中，end指定指令入口地址

mov ax ,[bx+200]  = mov ax,200[bx]           [bx+idata]进行数组的处理   这种形式为[bx+idata]

mov ax,[bx+si] 地址为：(ds) * 16 + (bx)+(si)

mov ax,[bi+si+idata]

不同的寻址方式的灵活应用：

*  **[idata]**用一个常量表示地址，可直接定位一个内存单元
* **[bx]**用一个变量表示内存地址，可用于间接定位一个内存单元
* **[bx + idata]**用一个变量和常量表示地址，可以在一个起始地址的基础上用变量间接定位一个内存单元
* **[bx + si]**用两个变量表示地址
* **[bx + si + idata]**

计算机是进行数据处理、运算的机器，有两个基本问题包含在其中：

* 处理的数据在什么地方
* 要处理的数据有多长

reg（寄存器）的集合包括：ax、bx、cx、dx、si、di、sp、bp

sreg（段寄存器）的集合包括：ds、ss、cs、es

对于bx、si、di和bp：

* 8086CPU只有这四个寄存器可以用在[....]进行内存单元的寻址
* [....]这4个寄存器可以单个出现，或只能以4种组合出现：bx和si，bx+di, bp+si, bp+di
* [....]出现bp，就会使用ss，否则使用ds

| 机器码   | 汇编指令   | 指令执行前数据的位置 |
| -------- | ---------- | -------------------- |
| 8E1E0000 | mov bx,[0] | 内存单元，ds:0       |
| 89C3     | mox bx,ax  | CPU内部，ax寄存器    |
| BB0100   | mox bxc,1  | CPU内部，指令缓冲器  |

立即数对于直接包含在机器指令种的数据（执行前在CPU的指令缓冲器）

| 寻址方式      | 含义                  | 名称             | 常用举例                                                     |
| ------------- | --------------------- | ---------------- | ------------------------------------------------------------ |
| [idata]       | EA=idata,SA=(ds)      | 直接寻址         | [idata]                                                      |
| [bx]          | EA=(bx),SA=(ds)       | 寄存器间接寻址   | [bx]                                                         |
| [si]          | EA=(si),SA=(ds)       | 寄存器间接寻址   |                                                              |
| [di]          | EA=(di),SA=(ds)       | 寄存器间接寻址   |                                                              |
| [bp]          | EA=(bp),SA=(ss)       | 寄存器间接寻址   |                                                              |
| [bx+idata]    | EA=(bx)+idata,SA=(ds) | 寄存器相对寻址   | 用于结构体：[bx].idata<br />用于数组：idata[si],idata[di]<br />用于二维数组：\[bx][idata] |
| [si+idata]    | EA=(si)+idata,SA=(ds) | 寄存器相对寻址   |                                                              |
| [di+idata]    | EA=(di)+idata,SA=(ds) | 寄存器相对寻址   |                                                              |
| [bp+idata]    | EA=(bp)+idata,SA=(ss) | 寄存器相对寻址   |                                                              |
| [bx+si]       | .....                 | 基址变址寻址     | 用于二维数组：\[bx][si]                                      |
| [bx+di]       | .....                 | 基址变址寻址     |                                                              |
| [bp+si]       | .....                 | 基址变址寻址     |                                                              |
| [bp+di]       | .....                 | 基址变址寻址     |                                                              |
| [bx+si+idata] | .....                 | 相对基址变址寻址 | 用于表格（结构）中的数组项：\[bx].idata[si]<br />用于二维数组：idata\[bx][si] |
| [bx+di+idata] | .....                 | 相对基址变址寻址 |                                                              |
| [bp+si+idata] | .....                 | 相对基址变址寻址 |                                                              |
| [bp+di+data]  | .....                 | 相对基址变址寻址 |                                                              |

指令要处理的数据有多长：

* 通过通用寄存器自动推断,例：mov ax,[12H]
* 操作符X ptr指示，例：mov word ptr ds:[0],1
* 有些指令默认了访问的字单元还是字节单元，例：push指令只进行字操作

8086CPU提供的如[bx + si + idata]的寻址方式为结构化数据的处理提供了方便

div指令：

* 除数，有8位和16位两种，在一个reg或内存单元中
* 被除数，默认放在ax或dx和ax中，如果除数为8位，被除数则为16位；如果除数是16位，被除数则为32位
* 结果，如果除数为8位，则AL存储商，AH存储余数；如果除数位16位，则AX存储上，DX存储余数

伪指令：

db-定义字节型数据，dw-定义字型数据，dd-定义双字型数据

dup，进行数据的重复  db 2 dup(1,2,3),定义6个字节数据，分别为1，2，3，1，2，3

#### 转移指令

操作符offset，offset start,取得标号start的偏移地址

jmp指令，无条件转移指令，可以只修改IP，也可以同时修改CS和IP

* 依据位移进行转移，jmp short 标号，段内短转移，对IP修改范围为-128~127。jmp short s 被翻译成jmp 0008，机器码为**EB03**

  EB03没有指定转移地址，但是03却指明了要跳往数据的位移

  jmp near ptr 标号，段内近转移-32768~32767

* jmp far ptr 标号，段间转移，EA 0B 01 BD 0B，高地址是转移的段地址，低地址是偏移地址

* jmp 16位reg，修改ip为reg中的值

* jmp word ptr 内存单元地址（段内转移）、jmp dword ptr 内存单元地址（段间转移）

jcxz指令，有条件转移指令，所有有条件转移指令都是短转移，在对应机器码中包含转移的位移，而不是目的地址，对IP修改范围为-128-127

如果(cx)=0,则转移到标号处执行

loop指令，循环指令，所有的循环指令都是**短转移**，在对应的机器码中包含转移的位移，对ip修改范围都为-128~127

**编译器对转移位移超界的检测：**

call和ret指令都是转移指令，都修改IP，或同时修改CS和IP

ret指令用栈中的数据，修改IP，实现近转移

retf指令用栈中的数据，修改CS、IP，实现远转移

CPU执行call指令时，进行两步操作：

* 将当前的ip或cs和ip压入栈中
* 转移

call指令不能实现短转移

call 标号   相当于 push ip  jmp near ptr 标号

call far ptr 标号 进行的段间转移

call 16位reg

call word ptr 内存单元地址

call dword ptr 内存单元地址

mul指令：

* 两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，一个放在8位reg或内存单元中；如果是16位，一个默认在AX中，一个默认在16位reg或内存单元
* 结果，如果是8位乘法，结果默认放在AX中；如果是16位乘法，高位默认放在DX中，低位在AX中放

call与ret指令共同支持了汇编语言编程中的模块化设计

除了用寄存器传递参数外，还有一个通用的方法是用栈来传递参数

如何避免寄存器的使用冲突，例如cx，通常用来记录循环次数，方案：

* 在子程序的开始，将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前恢复，可以用栈保存寄存器的内容。

###### 标志寄存器

CPU内部的寄存器，有一种特殊的寄存器，具有以下3种作用：

* 用来存储相关指令的某些执行结果；
* 用来为CPU执行相关指令提供行为依据；
* 用来控制CPU的相关工作方式。

这种特殊的寄存器在8086CPU中，被称为标志寄存器。8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)。

flag寄存器（标志寄存器）是按位起作用的，每一位都有专门的含义

![image-20211219001203864](C:\Users\dmzc\Desktop\Learing\os\images\assembly\image-20211219001203864.png)

**ZF标志：**

零标志位，记录相关指令执行后，其结果是否为0

8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如add、sub、mul、div、inc、or、add，它们大都是运算指令；有的指令的执行对标志寄存器没有影响，比如mov、push、pop等，它们大多是传送指令。

**PF标志**：

奇偶标志位,它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数

**SF标志**：

符号标志位，它记录相关指令执行后，结果是否为负

**CF标志：**

进位标志位。一般情况下，在进行无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。

**OF标志：**

溢出标志位，一般情况下，OF记录了有符号数运算的结果是否发生了溢出

```assembly
mov al,98
add al,99
add指令执行后：CF=0,OF=1,CPU执行add等指令时，就包含了两种含义：无符号数运算和有符号数运算。对于无符号数运算，CF标志记录是否进位；对于有符号数运算，用OF标志位标识是否溢出
```

**abc指令**

常进位加法指令，利用CF位上记录值

abc 操作对象1，操作对象2    =>   操作对象1 = 操作对象1  + 操作对象2  + CF

**sbb指令**

带借位减法，利用了CF位上记录的借位值

sbb 操作对象1，操作对象2    =>   操作对象1 = 操作对象1  - 操作对象2  - CF

TODO:多位的加减法实验？？？

**cmp指令**：

比较指令，功能相当于减法指令，只是不保存结果。指令执行后会对标志寄存器产生影响

**检测比较结果的条件转移指令**：

例如：jcxz就是一个条件转移指令，检测cx中的值，决定是否转移

CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果决定是否修改IP

![image-20211219015617347](C:\Users\dmzc\Desktop\Learing\os\images\assembly\image-20211219015617347.png)

**DF标志**：

方向标志位，在串处理指令中，控制每次操作后si、di的增减。

df=0 每次操作后si、di递增；反之递减

movsb movsw，只是串传送操作的一个步骤，一般来说和rep配合使用

rep movsb   =>   s:movsb   loop s

**rep**的作用就是根据cx的值，重复执行后面的串传送指令

**cld指令**：将标志位df置为0

**std指令**：将标志位df置为1

**pushf、popf**的功能是将标志寄存器的值压栈、出栈

TODO:

[真正用来学习微机原理及汇编的好书!_xkf321的博客-CSDN博客_微机原理书籍推荐](https://blog.csdn.net/xkf321/article/details/64947747)

#### 内中断

任何一个通用的CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接受到的信息进行处理。这种特殊的信息，可以称其为：**中断信息**

对于8086CPU，内部有以下情况发生时，将产生相应的中断信息：

* 除法错误，中断源0
* 单步执行，中断源1
* 执行into指令，中断源4
* 执行int指令，指令格式为int n,其中n为字节型立即数，是中断源

中断类型码是一个字节型数据，可以表示256种中断信息的来源

###### 中断向量表

中断处理程序入口地址的列表，在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处，即00000~003ff

一个表项占两个字节

**中断过程**：由中断类型码找到中断向量，并用它设置CS、IP，这个工作是由CPU的硬件自动完成的

8086CPU收到中断信息后，所引发的中断过程：

* 取得中断类型码
* 标志寄存器入栈
* 设置标志寄存器的第8位TF和第9位IF的值为0
* CS的内容入栈、IP内容入栈
* 设置中断处理程序的CS、IP

由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储到内存某段空间

中断处理程序的编写方法和子程序的相似：

* 保存用到的寄存器
* 处理中断
* 恢复用到的寄存器
* 用iret指令返回

**iret**指令通常和硬件自动完成的中断过程配合使用。恢复cs、ip，标志寄存器

一般情况下，CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的类型码为1

CPU提供单步中断功能的原因，为单步跟踪程序的执行过程，提供了实现机制

响应中断的特殊情况：

执行完向ss寄存器传输数据的指令后，即便发生中断，CPU也不会响应。

BIOS内容：

* 硬件系统的检测和初始化程序
* 外部中断和内部中断的例程
* 用于对硬件设备进行I/O的中断例程
* 其他和硬件相关的中断例程

BIOS、DOS例程的安装：

* 开机后，CPU加电，CS=0ffffh,ip=0,此处为一个跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序
* 初始化程序将建立BIOS所支持的中断向量，（只需将对应中断例程的地址登记都中断向量表即可）
* 硬件检测和初始化完成后，调用int 19h进行操作系统的引导
* dos启动后，除了完成其他工作，还将它所提供的中断例程装入内存，并建立相应的中断向量

BIOS和DOS所提供的中断例程，都用ah传递内部子程序的编号

```assembly
mov ah,2 //置光标
mov bh,0 //第0页
mov dh,5 //dh中放行号
mov dl,12 //dl中放列号
int 10h

```

bh中页号的含义：内存地址空间中，B8000H~BFFFFH共32kb空间，为80*25彩色字符模式的显示缓冲区。一屏的内容在显示缓冲区共占4000字节，显示缓冲区分8页，显示器可以显示任意一页的内容

在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下三种芯片：

* 各种接口卡上的接口芯片，它们控制接口卡进行工作
* 主板上的接口芯片，CPU通过它们对部分外设进行访问
* 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理

在这些芯片中，都有一组可以由CPU读写的寄存器

从CPU角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立一个统一的端口地址空间。

CPU可以直接读写以下三个地方的数据：

* CPU内部的寄存器
* 内存单元
* 端口

在PC系统中，CPU最多可以定位64KB个不同的端口，则端口地址范围为0~65535

对端口读写指令有两条：in和out，分别用于从端口读取数据和往端口写入数据

在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据

对0~255以内的端口进行读写时：用ax或al

对256~65535的端口进行读写时，端口号放到dx中

```assembly
mov dx,3f8h
in al,dx
out dx,al
```

**CMOS RAM芯片**：

* 包含一个**实时钟**（TODO:是什么？？？）和一个有128个存储单元的RAM存储器
* 该芯片靠电池供电
* 128字节的RAM中，内部实时钟占用0~0dh单元保存时钟信息，其余大部分用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息
* 该芯片内部有两个端口，端口地址为70h和71h，CPU通过这两个端口读写
* 70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM中读取的数据

**shl指令**：

逻辑左移，它的功能：

* 将一个寄存器或内存单元中的数据向左移位
* 将最后移出的一位写入到CF
* 最低位用0补充

如果移动位数大于0，必须将移动位数放在cl中

**shr指令**：逻辑右移，与shl操作相反

##### 外中断

CPU通过端口和外部设备进行联系

相关芯片要向CPU发出相应的中断信息，CPU在执行完当前指令后，可以检测发送过来的中断信息，引发中断过程，处理外设的输入

在PC系统中，外中断源一共有以下两类：

可屏蔽中断：是CPU可以不响应的中断，是否响应，要看标志寄存位IF设置

sti,设置IF=1;cli,设置IF=0

不可屏蔽中断：CPU必须响应的外中断，对于8086CPU，不可屏蔽的中断类型码固定为2。几乎所有由外设引发的中断，都是可屏蔽中断。不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。

























































