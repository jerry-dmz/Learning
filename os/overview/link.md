《程序员的修养》

**编译过程**：词法分析、语法分析、语义分析、源代码优化、代码生成、目标代码优化

* 词法分析。运用一种类似于**有限状态机**的算法将源代码的字符序列分割成一系列**记号**（**Token**）。有一个叫lex的程序可以实现词法扫描，会按照用户描述好的词法规则将输入的字符串分割成一个个记号。

* 语法分析。语法分析器对Tokens进行语法分析，从而产生语法树。整个分析过程采用了上下文无关语法的分析手段，以表达式为节点的树。语法分析也有一个现成的工具yacc，想lex一样，可以根据用户给定的语法规则对输入的记号序列进行解析。

* 语义分析。编译器能分析的语义是静态语义。静态语义通常包括声明和类型的匹配，类型的转换。

* 中间语言生成。直接在语法树上优化比较困难，所以源代码优化器往往将整个语法树转换成**中间代码**，它是语法树的顺序表示，它一般跟目标机器和运行时环境无关，比如不包含数据的尺寸、变量地址和寄存器的名字等。

  **中间代码**使得编译器可以被分为前端和后端，编译器前端负责产生机器无关的中间代码；编译器后端将中间代码转换成目标机器代码。对于一些可以跨平台的编译器，可以针对不同平台使用同一个前端编译和针对不同机器平台的数个后端。

* 目标代码生成及优化。编译器后端主要包括**代码生成器**和**目标代码优化器**。代码生成器将中间代码转换为目标机器代码，这个过程十分依赖目标机器。最后目标代码优化器对上述目标代码进行优化，比如选择合适的寻址方式、使用位移代替乘法、删除多余的指令

  在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是必须解决的问题。模块之间如何组合的问题可以归结为模块之间如何通信的问题，最常见的属于静态语言的C/C++模块之间通信，有两种方式，一种是模块间的函数调用，另外一种是模块间的变量访问。归结为模块间的符号引用。

链接过程主要包括了地址和空间分配、符号决议和重定位等这些步骤

**目标文件**

windows下的PE和Linux下的ELF，都是COFF（common file format）格式的变种。

不光是可执行文件按照可执行文件格式存储。动态链接库（windows下的.dll、linux下的.so）及静态链接库（windows下的.lib和linux下的.a）都按照可执行文件格式存储

| ELF文件类型  | 说明                                                         | 例子                         |
| ------------ | ------------------------------------------------------------ | ---------------------------- |
| 可重定位文件 | 静态链接库也可归结为这一类                                   | linux *.o,windows *.obj      |
| 可执行文件   | 可直接执行的程序                                             | /bin/bash  windows的*.exe    |
| 共享目标文件 | 这种文件包含了代码和数据。可以在一下两种情况使用。<br />一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接<br />产生新的目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件<br />结合，作为进程映像的一部分来运行 | linux的 *.so,windows的 *.dll |
| 核心转储文件 | 进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 | linux下的core dump           |

Unix最早的可执行文件格式为a.out格式，设计非常简单，以至于后来共享库这个概念出现的时候，a.out格式就变得捉襟见肘。于是设计了COFF格式来解决这些问题，这个设计非常通用。COFF的主要贡献是在目标文件里引入了“段”的机制，不同的目标文件可以拥有不同数量以及不同类型的“段”，另外，它还定义了调试数据格式。

数据和指令分段的好处：

* 程序装载时，数据和指令分别被映射到两个虚存区域。数据区域可读可写，指令区域可读，分开可以防止程序的指令被改写
* 对于现代CPU，有着强大的缓存体系，指令和数据的分离有利于提供成的局部性，现代CPU缓存一般都被设计成数据缓存和指令缓存分离。
* 当系统运行多个该程序的副本时，它们的指令是一样的，所以内存只需要保留一份该程序的指令部分



![image-20211207233301822](C:\Users\dmzc\Desktop\Learing\os\images\link\image-20211207233301822.png)

CONTENTS表示该段在文件中存在

size 可以用来查看ELF文件的代码段、数据段和BBS段的长度

objdump -s -d

.rodata存放只读数据，如const修饰变量和字符串常量

有些编译器会将全局未初始化变量存放在目标文件.bbs段，有些则不存放，只是预留一个未定义的全局变量符号，等到最终链接成可执行文件时再在.bbs段分配空间。

ELF中常用段名：

| 常用段名         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| .rodata1         | 这种段存放的是只读数据，比如字符串常量、全局const变量，跟".rodata"一样 |
| .comment         | 存放编译器版本信息                                           |
| .debug           | 调试信息                                                     |
| .dynamic         | 动态链接信息                                                 |
| .hash            | 符号hash表                                                   |
| .line            | 调试时的行号表                                               |
| .note            | 额外编译器信息                                               |
| .strtab          | 字符串表，用于存储ELF文件中用到的各种字符串                  |
| .symtab          | 符号表                                                       |
| .shstrtab        | 段名表                                                       |
| .plt<br />.got   | 动态链接的跳转表和全局入口表                                 |
| .init<br />.fini | 程序初始化与终结代码段                                       |

一个ELF文件可以拥有几个相同段名的段，比如两个或两个以上叫做".text"的段

objcopy -I binary -o elf32-i386 -B i386 image.jpg image.o

objdump -ht image.o

gcc提供扩展机制，支持自定义段名

**ELF文件结构描述**

readelf -h 

<img src="C:\Users\dmzc\Desktop\Learing\os\images\link\image-20211215213946113.png" alt="image-20211215213946113" style="zoom:80%;" />

/usr/include/elf.h中定义了文件头结构Elf32_Ehdr

e_ident对应了readelf中Class、Data、Version、OS/ABI和ABI Version这5个参数

**e_ident这16个字节被ELF标准规定用来标识ELF文件的平台属性**

**7f  45  4c  46  01  01  01  00  00    00  00   00  00   00  00   00**

最开始4个字节是所有ELF文件必须相同的标识码，第一个字节7f对Ascll码DEL控制符，剩下分别是 E L F的**ASCLL编码**，这四个字节又被称为魔数

第5个字节标识ELF的文件类，0x01表示是32位，0x02表示是64位，0x00无效

第6个字节是字节序， 0x01小端，0x02大端，0x00无效

第7个字节规定ELF文件的主版本号，一般是1，因为ELF标准自1.2版以后就没有更新



**.out格式文件魔数的由来：**

UNIX早期是在PDP小型机上诞生的，当时系统加载一个可执行文件后直接从文件的第一个字节开始执行，一般在文件的最开始放置一条跳转指令，这条指令负责跳过接下来7个字节的的文件头到可执行文件的真正入口。而0x01 0x07刚好是当时PDP-11的机器跳转7个机器字的指令。

**e_type:**ELF文件类型：

| 常量    | 值   | 含义         |
| ------- | ---- | ------------ |
| ET_REL  | 1    | 可重定位文件 |
| ET_EXEC | 2    | 可执行文件   |
| ET_DYN  | 3    | 共享目标文件 |

**e_machine(机器类型)**:

![image-20211215222024638](C:\Users\dmzc\Desktop\Learing\os\images\link\image-20211215222024638.png)

**段表**（**section headers**），保存段的基本属性，如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。elf文件头**e_shoff**指定了段表的偏移地址

objectdump -h只是把ELF文件中关键段显示出来，而省略其他的辅助性段，可以用readelf

![image-20211215222752503](C:\Users\dmzc\Desktop\Learing\os\images\link\image-20211215222752503.png)

```c
typedef struct{
    sh_name;//段名在.shstrtab字符串表中偏移
    sh_type;//段类型
    sh_flags;//段标志位
    sh_addr;//Section Address(段虚拟地址)，如果该段可以被加载，则sh_addr为该段加载后在进程地址空间的虚拟地址；否则为0
    sh_offset;//Section Offset段偏移，如果该段存在于文件中，则表示文件中的偏移，否则无意义，比如BBS段
    sh_size;//段长度
    sh_link;//Section Link and Section Information段链接信息
    sh_info;//
    sh_addralign;//Section Address Alignment 段地址对齐
    sh_entsize;
} Elf32_Shdr
```

**sh_type枚举：**

| 常量         | 值   | 含义                               |
| ------------ | ---- | ---------------------------------- |
| SHL_NULL     | 0    | 无效段                             |
| SHL_PROGBITS | 1    | 程序段、代码段、数据段都是此类型   |
| SHL_SYMTAB   | 2    | 符号表                             |
| SHL_STRTAB   | 3    | 字符串表                           |
| SHL_SHTRELA  | 4    | 重定位表，包含重定位信息           |
| SHL_HASH     | 5    | 符号表的hash表                     |
| SHL_DYNAMIC  | 6    | 动态链接信息                       |
| SHL_NOTE     | 7    | 提示性信息                         |
| SHL_NOBITS   | 8    | 表示该段在文件中无内容，比如.bbs段 |
| SHL_REL      | 9    | 包含重定位信息                     |
| SHL_SHLIB    | 10   | 保留                               |
| SHL_DNYSYM   | 11   | 动态链接符号表                     |

**sh_flag枚举：**

| 常量          | 值   | 含义                                                         |
| ------------- | ---- | ------------------------------------------------------------ |
| SHF_WRITE     | 0    | 该段在进程可写                                               |
| SHF_ALLOC     | 1    | 该段在进程须要分配空间，有些包含指示或控制信息的段不须要在进程空间分配空间，像<br />代码段、数据段和.bbs段都会有这个标志位 |
| SHF_EXECINSTR | 2    | 表示该段在进程空间可以被执行，一般值代码段                   |

![image-20211215230445664](C:\Users\dmzc\Desktop\Learing\os\images\link\image-20211215230445664.png)

![image-20211215230711377](C:\Users\dmzc\Desktop\Learing\os\images\link\image-20211215230711377.png)

**重定位表：**

.rel.text  sh_type为**SHT_REL**

**字符串表**：？？？

##### 链接的接口-符号：

链接过程的本质就是把多个不同的目标文件“粘”到一起。为了使不同目标文件能够相互粘合，这些目标文件之间必须有**固定的规则**。

在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用，统称为**符号**

可以把**符号**看作链接中的粘合剂，整个链接过程正是基于符号才能正确完成。每一个目标文件都有一个相应的**符号表**，记录目标文件中所有用到的符号。每个定义的符号有一个对应的值，叫做**符号值**，对于变量和函数来说，符号值就是它们的地址

**符号类型**还有：

* 定义在本目标文件中的全局符号，可以被其他目标文件引用
* 在本目标中引用的全局符号，却没有定义在本目标文件，一般叫做**外部符号**
* 段名，这种符号往往由编译器产生，它的值就是该段的起始地址
* 局部符号，只在编译单元内部可见，调试器可以使用这些符号来分析程序或崩溃时的核心转储文件，这些局部符号对于链接过程无用
* 行号信息，目标文件和源代码中代码行的对应关系

符号表往往是文件中的一个段，“.symtab”,是一个Elf32_Sym结构

```c
typedef struct{
    st_name;//符号名在字符串表中下标
    st_value;//符号对应值，
    st_size;//符号大小
    st_info;//符号类型和绑定信息
    st_other;
    st_shndx;//符号所在段
} Elf32_Sym;
```

**st_info**:低四位表示符号的类型，高28位表示符号绑定信息

符号绑定信息

| 宏定义名   | 值   | 说明                           |
| ---------- | ---- | ------------------------------ |
| STB_LOCAL  | 0    | 局部符号，对目标文件外部不可见 |
| STB_GLOBAL | 1    | 全局符号，外部可见             |
| STB_WEAK   | 2    | 弱引用                         |

符号类型

| 宏定义名    | 值   | 说明                                                         |
| ----------- | ---- | ------------------------------------------------------------ |
| STT_NOTYPE  | 0    | 未知类型符号                                                 |
| STT_OBJECT  | 1    | 该符号是个数据对象，比如变量、数组等                         |
| STT_FUNC    | 2    | 该符号是个函数或其他可执行代码                               |
| STT_SECTION | 3    | 表示一个段，必须是STB_LOCAL                                  |
| STT_FILE    | 4    | 表示文件名，一般都是目标文件对应源文件名，一定是STB_LOCAL,st_shndx一定是SHN_ABS |

st_shndx(符号所在段)：如果符号定义在本目标文件，那么这个成员表示符号所在的段在段表的下表；但是符号如果不是定义在本目标文件中，或则对于有些特殊符号，sh_shndx就有些特殊：

| 宏定义名   | 值   | 说明                                                       |
| ---------- | ---- | ---------------------------------------------------------- |
| SHN_ABS    | 0    | 包含一个绝对的值，表示文件名的符号就属于这种               |
| SHN_COMMON | 1    | 未初始化的全局符号定义就是如此                             |
| SHN_UNDEF  | 2    | 符号未定义，表示该符号在本目标文件引用，但是在其他文件引用 |

**st_value**符号值：如果这个符号是一个函数或变量的定义，那么符号的值就是这个函数、变量的地址

* 如果是符号的定义，并且该符号不是COMMON块类型的，符号所对应的函数或变量位于由st_shndx指定的段，偏移st_value的位置
* 如果是COMMON块类型的，st_value表示该符号的对齐属性
* 可执行文件中，st_value表示符号的虚拟地址

**特殊符号**：使用ld作为链接器来链接生产可执行文件时。会为我们定义很多特殊的符号，可以直接引用

GCC 基本C++名称修饰方法：**所有符号**以"_Z"开头；对于**嵌套的名字**(在名称空间或类里面的)，后面紧跟“N”，然后是各个名称空间或类的名字；参数列表紧跟在**E**后

N:C:func  =>  **_ZN** **1N** **1C** **4func** **Ei**

**c++filt** 工具可以用来解析被xiu'shi过的名称

签名和名称修饰机制不光被使用到函数上，C++中的全局变量和静态变量也有同样的机制。**变量的类型没有被加到修饰后名称中**。

名称修饰机制也被用来防止静态变量的名字冲突

C++为了和C兼容，在符号的管理上，C++有一个用来声明或定义一个C的符号的’extern “C” ‘关键字用法

extern "C"{

int func(int);

int var;

}

C++编译器会将extern “”C“的大括号内部的代码当作C语言代码处理。

C++的宏”_cplusplus“

**弱符号与强符号**

对于C/C++语言，编译器默认函数和初始化了的全局变量为”**强符号**“，未初始化的全局变量为”弱符号“

* 不允许强符号被多次定义（即不同的目标文件中不能有同名的强符号）；如果有多个强符号定义，链接器报错；
* 如果一个符号在某个目标文件中是强符号，在其他文件都是弱符号，那么选择强符号；
* 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。

**强引用和弱引用**：对于强引用，如果没有找到该符号的定义，链接器就会报符号未定义错误。与之相对的还有一种弱引用，在处理弱引用时，如果该符号有定义，则链接器将该引用的符号决议；如果该符号未被定义，则链接器对于该引用不报错。链接器处理强引用和弱引用的过程几乎一样，只是对于未定义的弱引用，链接器不认为它是一个错误。一般对于未定义的弱引用，链接器默认为0，或者一个特殊的值。

```c
__attribute__ ((weakref)) void foo();
int main()
{
	foo();
}
不会报链接错误，运行时会发生非法地址访问
```

这种**弱符号和弱引用**对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使程序可以使用自定义版本的库函数；或者程序可以对某些扩展功能模块的引用定义为弱引用，当链接器将扩展模块与程序链接到一起时，功能模块就可以正常使用；如果去掉了某些功能模块，程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更加容易裁剪和组合。

在linux程序设计中，如果一个程序被设计成可以支持单线程或多线程的模式，就可以通过弱引用的方法来判断当前的程序时链接到了单线程的Glibc库还是多线程的glibc库，从而执行单线程版本还是多线程版本程序。

**调试信息**

几乎所有现代的编译器都支持的源代码级别的调试

GCC编译时加上-g参数，就会在目标文件里面加上调试信息。现在的ELF文件采用一个叫DWARF的标准的调试信息格式。linux下可以使用strip命令取出ELF文件中的调试信息。

##### 静态链接

链接器如何将段合并到输出文件？

1.按序叠加，输出文件中会有很多零散的段，而每个段都有一定的地址和空间对齐要求，对于x86硬件来说，段的装载地址和空间的对齐单位是页，也就是4096字节，如果一个段只有几十字节，会造成大量的内部碎片

2.比较实际的方案，将相同性质的段合并到一起

”.bbs“段在目标文件和可执行文件中并不占用文件的空间，但是它在装载时占用地址空间，所以bbs段也要合并，并分配虚拟空间

基本都使用第二种方案，两步链接：

**第一步**，**空间与地址分配**，扫描所有的输入目标文件，并且获得它们各个段的长度、属性和位置，并且将输入目标文件中的符号表中的所有符号定义和符号引用收集起来，同一放到一个全局符号表。这一步中，链接器能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度

符号表、字符串表是不是一个段？？？TODO:

**第二步**，**符号解析与重定位**，使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行**符号解析与重定位、调整代码中的地址**等。

```c
/*a.c*/
extern int shared;
int main(){
    int a = 100;
    swap(&a,&shared);
}
/*b.c*/
int shared=1;
void swap(int * a,int *b){
    *a ^= *b ^= *a ^= *b; 
}
gcc -c a.c b.c  //得到a.o,b.o
ld a.o b.o -e main -o ab  //-e main将函数作为程序入口，ld链接器默认程序入口为_start

```

使用objdump查看，VMA（Virtual Memory Address）即虚拟地址；LMA（Load Memory Address）即加载地址。正常情况下，两个值应该是都一样的，但是有些嵌入系统中，特别是那些程序放在ROM的系统中时，VMA和LMA是不相同的

链接后的程序中所使用的地址已经是程序在进程中的虚拟地址。在linux下，ELF可执行文件默认从地址**0x08048000**开始分配

在完成空间和地址分配之后，链接器就进入了符号解析与重定位的步骤。

对于可重定位的ELF文件来说，必须包含重定位表，用来描述如何修改相应的段里的内容.一个重定位表往往就是ELF文件的一个段.

每个要被重定位的地方叫一个**重定位入口**:

| r_offset   | 对可重定位文件来说,该重定位入口所要修正的位置的第一个字节相对于段起始的偏移<br />对可执行文件或共享文件来说,该重定位入口所要修正位置的第一个字节的虚拟地址 |
| ---------- | ------------------------------------------------------------ |
| **r_info** | **低8位表示重定位入口的类型,高24表示重定位入口的符号在符号表的下标.<br />因为各种处理器的指令格式不一样,所以重定位所修正的指令地址格式也不一样,每种处理器都有自己的一套重定位入口的类型** |

指令修正方式:

不同的处理器指令对于地址的格式和方式都不一样.比如对于32位Intel x86处理器,jmp call  mov指令寻址方式千差万别.知道2006年为止,Intel x86系列CPU的jmp指令,call指令有10种,mov则多达34种,这些寻址方式有以下差别:

* 近址寻址或远址寻址
* 绝对寻址或相对寻址
* 寻址长度为8位 16位  32位或64位

对于32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种:

* 绝对近址32位寻址

* 相对近址32位寻址

  这两种重定位方式指令修正方式,每个被的位置的长度都为32位,而且都是近址寻址,不用考虑Intel的段间远址寻址

为什么有远址寻址  近址的概念???TODO:

x86基本重定位类型:

| 宏定义     | 值   | 重定位修正方法         |
| ---------- | ---- | ---------------------- |
| R_386_32   | 1    | 绝对寻址修正 S + A     |
| R_386_PC32 | 2    | 相对寻址修正 S + A - P |

A = 保存在被修正位置的值(指令中偏移值)

P = 被修正的位置(相对于段开始的偏移量或虚拟地址)

S = 符号的实际地址

现代链接机制在处理弱符号时,采用就是与COMMON块一样的机制.不同的目标文件需要的相同弱符号的COMMON块空间大小不一致时,以最大的那块为准.

直接导致需要COMMON块机制的原因是编译器和链接器允许不同类型的弱符号存在,但最本质的原因还是链接器不支持符号类型,即链接器无法判断各个符号的类型是否一致.

目标文件中,编译器为什么不直接把**未初始化的全局变量**也当作**未初始化的局部静态变量**一样处理,为**未初始化的局部静态变量**在BBS段分配空间,而是将其标记为一个COMMON类型的变量?

​      编译目标文件时,如果编译单元包含了弱符号,那么该弱符号最终所占空间是未知的,所以编译器无法为该弱符号在BBS段分配空间.但是链接器在链接过程可以确定弱符号大小,所以,可以在最终输出文件的BBS段为其分配空间.所以,总体来看,未初始化全局变量最终还是被放在BBS段.

GCC的"-fno-common"也允许我们把所有未初始化的全局变量不以COMMON块形式处理,或者用"\__attribute__"扩展,此时就相当于一个强符号

C++相关问题:

C++的一些语言特性使之必须由编译器和链接器共同支持才能完成工作.主要有两个方面,一个是C++的重复代码消除,一个是全局构造和析构.另外由于C++语言的各种特性,比如虚拟函数 函数重载 继承 异常等,使得它背后的数据结构异常复杂,这些数据结构往往在不同编译器和链接器之间不能通用,使得C++程序的二进制兼容性成了一个很大的问题

LVMM   ???TODO:

* 重复代码消除,模板 外部内联函数和虚函数表都有可能在不同编译单元生成相同代码.

  一个有效的做法是将每个摸板的实例代码都单独存放在一个段,每个段之包含一个模板实例,这样链接器在最终链接时可以区分这些相同的摸板实例段,然后将它们合并入最后的代码段.

  这种做法被目前主流编译器采用,GCC把这种类似的需要在最终链接时合并的段叫"Link Once",它的做法是将这种类型的段命名为".gnu.linkonce.name"

  函数级别链接,GCC编译器提供机制,"-ffunction-sections"和"-fdata-sections",将每个函数或变量分别保持到独立的段.

* 全局构造和析构

  一般的一个C/C++程序是从main开始执行的,随着main函数的结束而结束.然而,在main函数被调用之前,为了程序能够顺利执行,要先初始化进程执行环境,比如堆分配初始化 线程子系统等.C++全局对象的构造函数就是在这一时期执行的,C++全局对象的析构函数在main之后被执行.

  Linux系统下一般程序的入口是"_start",这个函数是Linux系统库(Glibc)的一部分.当程序与Glibc链接在一起形成最终可执行文件之后,这个函数就是程序的初始化部分的入口,程序初始化部分完成一系列初始化过程之后,会调用main函数执行程序主体.在main函数执行完成之后,会返回初始化部分,进行一些清理工作,然后后结束进程.

  ELF文件还定义了两种特殊的段:

  * .init 该段保存可执行指令,构成进程的初始化代码
  * fini 该段保存进程终止代码指令.

如果将两个不同编译器的编译结果链接到一起,那么这两个目标文件必须满足下面这些条件:采用同样的目标文件格式   拥有同样的符号修饰标准   变量的内存分布方式相同,函数的调用方式相同,等等.其中,把符号修饰标准  变量内存布局  函数调用方式这些跟可执行代码二进制兼容性相关内容称为ABI

库有很多常用函数,比如,C语言标准库中函数strlen,该函数遍历整个字符串后返回字符串长度,这个函数并没有调用任何操作系统的API,但是很大一部分库函数都是调用操作系统的API的

一个静态库可以简单看成一组目标文件的集合,linux下最常用的静态库libc位于/usr/lib/libc.a,属于glibc项目的一部分;像Windows平台上,最常使用的C语言库是由集成开发环境所附带的运行库,这些库一般由编译器厂商提供.

ar压缩程序将目标文件压缩到一起,并对其进行编号和索引,以便于查找和检索.

gcc  "-fno-builtin"参数关闭内置优化选项.

gcc -static --verbose -fno-builtin  hello.c,能把编译过程中的中间步骤都打印出来

ccl编译  as汇编  collect2完成最后链接

collect2是ld链接器的一个包装,会调用ld链接器完成对目标文件的链接,然后对链接结果进行一些处理,主要是所有与程序初始化相关信息并且构造初始化的结构.

链接过程控制:

绝大部分情况下,使用链接器提供的默认链接规则对目标文件进行链接.这在一般情况下,是没有问题的,但对于一些特殊要求的程序,比如操作系统内核  BIOS或一些在没有操作系统情况下运行的程序(如引导程序Boot Loader或者嵌入式系统的程序,或者一些脱离操作系统的硬盘分区软件PQMagic等),以及另外一些必须要特殊的链接过程的程序,如一些内核驱动程序等,它们往往会受限于一些特殊的条件,如需要指定输出文件的各个段虚拟地址 段的名称 段存放的顺序等,因为这些特殊的环境,特别是某些硬件条件的限制,往往对程序的各个段的地址有着特殊的要求

整个链接过程由很多内容需要确定

操作系统内核,本质上就是一个程序.比如windows内核ntoskrnl.exe就是一个平常看到的PE文件

**链接控制脚本:**

链接器一般都提供多种控制整个链接过程的方法,以用来产生用户所需要的文件.

* 使用命令行给链接器指定参数
* 将链接指令放在目标文件中.编译器通常通过这种方法向链接器传递指令.visual c++编译器会把链接参数放到PE目标文件的.drective段
* 使用链接器脚本

ld在用户没有指定链接脚本的时候,会使用默认链接脚本 ld --verbose即可查看默认链接脚本

默认链接脚本存在/usr/lib/ldscripts下,不同机器平台 输出文件格式都有相应的链接器脚本

**BFD库:**

通过一种统一的接口来处理不同的目标文件格式.BFD本身就是binutils项目的一个子项目.BFD把目标文件抽象成一个统一的模型.使用BFD库的程序只需要通过操作这个抽象的目标文件模型就可以实现操作所有BFD支持的目标文件格式.

现在GCC  链接器ld 调试器GDB及binutils的其他工具都通过BFD库来处理目标文件,而不是直接操作目标文件.这样,将编译器和链接器本身同具体的目标文件格式隔离开来,目前BFD库支持大约25种处理器平台,将近50种目标文件格式.

**装载**

早期的装载程序十分简陋,装载的基本过程就是把程序从外部存储器种读取到内存种某个位置,随着硬件MMU的诞生,多进程 多用户 虚拟存储的操作系统的出现以后,可执行文件的装载变得非常复杂.

每个程序被运行起来后,它将拥有自己独立的**虚拟地址空间**(**Vitrual Address Space**),这个虚拟地址空间的大小由计算机的硬件平台决定,具体来说由CPU的位数决定.硬件决定地址空间的最大理论上限

32位平台下的4GB虚拟空间,程序是否能够任意使用?

程序的运行的时候处于操作系统的监管之下,操作系统为了达到监控程序运行等一系列目的,进程的虚拟空间都在操作系统的监管下.进程只能使用那些那些操作系统分配给进程的地址 Segmentation fault

默认情况下,Linux操作系统将4GB划分为两部分,从地址0xC0000000到0xFFFFFFFF,共1GB,供操作系统使用.剩下的都是留给进程使用的

**PAE(Physical Address Extension):**

Intel自从1995年的Pentium Pro CPU开始采用36位的物理地址,也就是可以访问高达64GB的物理内存.从硬件层面上,原先的32地址线只能访问最多4GB的物理内存,但是自从扩展至36位地址线之后,Intel修改了页映射的方式,使得新的映射方式可以访问更多的物理内存.

当然,扩展的物理地址空间,对于普通应用的程序来说正常情况下感觉不到它的存在,在应用程序里,只有32位的虚拟地址.那么应用程序应该如何使用这些大于常规的内存空间呢?一个常见的方法就是操作系统提供一个窗口映射的方法,把这些额外的内存映射到进程地址空间中来.应用程序可以根据需要选择申请和映射.

这只是一种补救32位地址空间不够大时的非常手段.

**程序的装载方式:**

**覆盖装入**和**页映射**是两种很典型的动态装载方法.原则上利用了程序的局部性原理.

**覆盖装入**在没有发明虚拟存储之前使用广泛,在一些嵌入式的内存受限环境下,特别是诸如DSP等,覆盖装入或许用武之地

**覆盖装入**把挖掘内存潜力的任务交给了程序员,程序员在编写程序的时候必须手工将程序分割成若干块,然后编写一个小的辅助代码来管理这些模块何时应该驻留内存而何时应该被替换掉(Overlay Manager)**覆盖管理器**.在多个模块的情况下,程序需要**手工将模块按照它们之间的调用依赖关系组织成树状结构**

**页映射:**

页映射是虚拟存储机制的一部分.将内存和所有磁盘中的数据和指令按照"页"为单位划分成若干个页,之后所有的装载和操作的单位都是页.以目前的情况,硬件规定的页的大小有4096字节   8192字节   2MB    4MB等,最常见的IA32处理器一般都使用4096字节大小的页

创建一个进程:

* 创建一个独立的虚拟地址空间.

  创建映射函数所需要的相应的数据结构,在i386的Linux下,创建虚拟地址空间实际上只是分配一个页目录,甚至不设置映射关系,这些映射关系等到后来程序发生页错误的时候在进行设置

* 读取可执行文件头,并且建立虚拟空间和可执行文件的映射关系

  上一步的页映射关系函数是虚拟空间到物理内存的映射关系.这一步所做的是虚拟空间与可执行文件的映射关系(操作系统捕获缺页错误时,应该知道程序当前所需要的页在可执行文件中的哪一个位置,这就是虚拟空间与可执行文件之间的关系).

* 将CPU的指令寄存器设置成可执行文件的入口地址,启动运行

上述操作完成后,其实可执行文件的真正指令和数据都没有被装入到内存,操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系.

进程虚存空间分布

ELF文件中,段的权限往往只有为数不多的几种组合:

* 以代码段为代表的权限为可读可执行的段
* 以数据段和bbs段为代表的权限为可读可写的段
* 以只读数据段为代表的权限为只读的段

**对于相同权限的段,把它们合并到一起当作一个段进行映射**

一个segment包含一个或多个属性类似的section

ELF可执行文件中有一个专门的数据结构,叫做**程序头表**,用来保存这些"segment"的值

```c
typedef struct{
    p_type;//
    p_offset;//"Segment"在文件中偏移
    p_vaddr;//"Segment"的第一个字节在进程虚拟地址空间的起始位置,整个程序头表中,所有"LOAD"类型元素按照p_vaddr从小到大排列
    p_paddr;//"Segment"物理装载地址,一般和p_vaddr相同
    p_filesz;//"Segment"在ELF文件中所占空间的长度,值可能为0
    p_memsz;//"Segment"在进程虚拟地址空间所占用长度
    P_flags;//权限属性
    p_align;//对齐属性
}Elf32_phdr
```

其中,p_memsz可能大于p_filesz,因为bbs段会合并到数据段中

**堆和栈:**

操作系统中,**VMA**除了被用来映射执行可执行文件中的各个"Segment"以外,操作系统还通过使用VMA来对进程的地址空间进行管理,堆和栈在进程的虚拟空间中的表现也是以VMA的形式存在的,很多情况下,一个进程中的堆和栈分别都有一个对应的VMA.

一个进程基本可分为以下几种VMA区域:

* 代码VMA,权限只读 可执行:有映像文件
* 数据VMA,权限可读写 可执行:有映像文件
* 堆VMA,权限可读写 可执行:无映像文件,匿名,可向上扩展
* 栈VMA,权限可读写 不可执行;无映像文件,匿名,可向下扩展

对于多个段映射,从物理页-->虚拟页的映射**TODO:**

进程栈初始化,进程刚启动时,须知道一些进程运行的环境,最基本的就是系统环境变量和进程的运行参数.很常见的一种做法是操作系统在进程启动前将这些信息提前保存到进程的虚拟空间的栈中.

进入execve系统调用后,linux内核就开始了真正的装载工作.入口为sys_execve(),这个入口函数进行一些参数的检查复制之后,调用do_execve().do_execve会首先查找被执行的文件,取前128字节判断文件的格式,ELF头4个字节为0x7F,而shell  python  perl开头通常是#!/bin/sh这些字符串

当do_execve读取到这128个字节的文件头之后,然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程.Linux中所有被支持的可执行文件格式都有相应的装载处理过程.elf可执行文件的装载处理过程叫做load_elf_binary()

load_elf_binary的主要步骤:

* 检查ELF可执行文件格式的有效性,比如魔数  程序头表中段的数量
* 寻找动态链接的".interp"段,设置动态链接器段
* 根据ELF可执行文件的程序头表描述,对ELF文件进行映射
* 初始化ELF进程环境
* 将系统调用的返回地址修改成ELF可执行文件的入口点.对于静态链接,就是ELF文件的文件头中e_entry地址;对于动态链接,程序入口点是动态链接器.

**动态链接:**

动态链接出现的原因:

* 静态链接浪费空间
* 对程序的更新 部署和发布也很麻烦

动态链接的基本思想是将链接的过程推迟到运行时再进行

磁盘和内存中只存在一份共享库Lib.o,也可以减少物理页面的换入换出,也可以增加CPU缓存的命中率

当升级程序库或程序共享的某个模块时,理论上只需要简单的将旧的目标文件覆盖掉,而无须将所有的程序再重新链接起来.

程序可以在运行时动态地选择加载各种程序模块,这个特点被用来制作程序地插件:

比如某个公司开发完成了一个产品,它按照一定地规则制定好程序地接口,其他公司或开发者可以按照这种接口编写符合要求地动态链接文件.该产品程序可以动态载入各种由第三方开发的模块,在程序运行时动态地链接,实现程序功能地扩展

动态链接还可以加强程序的兼容性.一个程序在不同的平台运行时可以动态地链接到由操作系统提供的动态链接库

动态链接的基本实现:

把程序按照模块拆分成各个相对独立部分,在程序运行时才将它们链接在一起形成一个完整的程序.

动态链接涉及运行时的链接及多个文件的装载,必需有操作系统的支持,因为动态链接的情况下,进程的虚拟地址空间的分布会比静态链接情况下更为复杂,还有一些存储管理 内存共享 进程线程等机制在动态链接下也会有一些微妙的变化.Linux中,ELF动态链接文件被称为动态共享对象(**DSO,Dynamic Shared Objects**),一般以".so"结尾,Windows系统中,被称为动态链接库(**DLL,Dynamic Linking Library**),通常以".dll"为扩展名

Linux中,常用的C语言库的运行库glibc,它的动态链接形式保存在/lib目录下,libc.so.当程序被装载时,系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间,并且将程序中所有未决议的符号绑定到相应的动态链接库中,并进行重定位工作

**固定装载地址的困扰**:

共享对象被装载时,如何确定它在虚拟地址空间中的位置?

早期的做法,**静态共享库**,将程序的各种模块统一交给操作系统来管理,操作系统在某个特定的地址划分出一些地址块,为已知的模块预留足够的空间.

为了解决装载地址固定的问题,设想是否可以让共享对象在**任意地址**加载?**共享对象在编译时不能假设自己在进程虚拟地址空间中的位置**.与此不同的是,可执行文件基本可以确定自己在进程虚拟空间中的起始位置,因为可执行文件往往是第一个被加载的文件,可以选择一个固定空闲的地址.Linux下一般是0x08040000,windows一般是0x0040000

在链接时,对所有绝对地址的引用不作重定位,而不这一步推迟到装载时在完成.一旦模块装载地址确定,即目标地址确定,那么系统就对程序中所有的绝对地址引用进行重定位

这种方法并不适合解决共享对象中所存在的问题.动态链接模块被装载映射至虚拟空间后,指令部分是在多个进程之间共享,因为指令被重定位后对于每个进程是不同的.当然动态链接库中的可修改数据部分对于不同进程来说有多个副本,所以可以采用装载时重定位的方法解决

Linux和GCC支持这种装载时重定位的方法,如果只使用"-shared",那么输出的共享对象就是使用装载时重定位的方法

装载时重定位是解决动态模块中有绝对地址引用的办法之一.但是它有一个很大的缺点,**指令部分无法在多个进程之间共享**.



希望程序模块中共享的指令部分在装载时不需要因为装载的地址改变而改变,所以实现的基本方法就是把指令中那些需要修改的部分分离出来,跟数据部分放在一起,(这样指令就可以共享,数据部分每个进程都有一个副本,可以随意修改)**地址无关代码(PIC,Position-independent Code)的技术**

* 模块内部的函数调用 跳转等

  相对地址调用

* 模块内部的数据访问,比如模块中定义的全局变量 静态变量

  相对寻址

* 模块外部的函数调用 跳转

  **GOT(Global Offset Table)全局偏移表**.当指令访问变量b时,首先会找到GOT,然后根据GOT中变量所对应项找到变量的目的地址.链接器在**装载模块**时会查找每个变量所在的地址,然后**填充GOT中的每个项**,以确保每个指针所指向的地址正确

* 模块外部的数据访问,比如其他模块中定义的全局变量



动态链接的原理基本弄懂了,这本书剩下的还有:

关于库的实践

windows PE的结构

过段时间,将ELF的结构 概念整理一遍,然后学习具体对二进制进行分析













